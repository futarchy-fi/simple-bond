<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SimpleBond — Futarchy</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@web3auth/modal@9/dist/modal.umd.min.js"></script>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --border: #2a2a3a;
    --text: #e0e0e8;
    --muted: #8888a0;
    --accent: #6c5ce7;
    --accent-hover: #7d6ff0;
    --green: #00b894;
    --red: #e74c3c;
    --orange: #f39c12;
    --blue: #3498db;
    --surface-hover: #1a1a24;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    line-height: 1.5;
  }
  .container { max-width: 640px; margin: 0 auto; padding: 24px 16px; }
  header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 16px 0; border-bottom: 1px solid var(--border); margin-bottom: 32px;
  }
  header h1 { font-size: 20px; font-weight: 600; }
  header h1 span { color: var(--muted); font-weight: 400; }
  .wallet-info { text-align: right; font-size: 13px; }
  .wallet-info .address { color: var(--accent); font-family: monospace; }
  .wallet-info .chain { color: var(--muted); font-size: 11px; }
  .wallet-info .disconnect-link {
    color: var(--muted); font-size: 11px; cursor: pointer;
    text-decoration: underline; margin-top: 2px;
  }
  .wallet-info .disconnect-link:hover { color: var(--red); }
  button {
    background: var(--accent); color: #fff; border: none; padding: 10px 20px;
    border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500;
    transition: background 0.15s;
  }
  button:hover { background: var(--accent-hover); }
  button:disabled { opacity: 0.4; cursor: not-allowed; }
  button.secondary { background: var(--surface); border: 1px solid var(--border); color: var(--text); }
  button.secondary:hover { border-color: var(--muted); }
  button.danger { background: var(--red); }
  button.success { background: var(--green); }
  .card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; padding: 24px; margin-bottom: 24px;
  }
  .card h2 { font-size: 16px; margin-bottom: 16px; font-weight: 600; }
  .form-group { margin-bottom: 14px; }
  .form-group label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 4px; }
  input, select, textarea {
    width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text); font-size: 14px; outline: none;
    font-family: inherit;
  }
  input:focus, select:focus, textarea:focus { border-color: var(--accent); }
  input::placeholder, textarea::placeholder { color: var(--muted); }
  textarea { resize: vertical; min-height: 60px; }
  .btn-row { display: flex; gap: 8px; margin-top: 16px; }
  .btn-row button { flex: 1; }
  .status-badge {
    display: inline-block; padding: 3px 10px; border-radius: 12px;
    font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;
  }
  .status-active { background: rgba(0,184,148,0.15); color: var(--green); }
  .status-forfeited { background: rgba(231,76,60,0.15); color: var(--red); }
  .status-settled { background: rgba(108,92,231,0.15); color: var(--accent); }
  .status-withdrawn { background: rgba(136,136,160,0.15); color: var(--muted); }
  .status-expired { background: rgba(243,156,18,0.15); color: var(--orange); }
  .status-timedout { background: rgba(243,156,18,0.15); color: var(--orange); }
  .status-pending { background: rgba(52,152,219,0.15); color: var(--blue); }
  .status-won { background: rgba(0,184,148,0.15); color: var(--green); }
  .status-lost { background: rgba(231,76,60,0.15); color: var(--red); }
  .status-refunded { background: rgba(136,136,160,0.15); color: var(--muted); }
  .bond-detail { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  .bond-field .label { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
  .bond-field .value { font-size: 14px; word-break: break-all; }
  .bond-field .value a { color: var(--accent); text-decoration: none; }
  .bond-field .value a:hover { text-decoration: underline; }
  .bond-field.full { grid-column: 1 / -1; }
  .actions { margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border); }
  .msg { padding: 10px 14px; border-radius: 8px; margin-top: 12px; font-size: 13px; }
  .msg-error { background: rgba(231,76,60,0.12); color: var(--red); }
  .msg-success { background: rgba(0,184,148,0.12); color: var(--green); }
  .msg-info { background: rgba(108,92,231,0.12); color: var(--accent); }
  .tabs { display: flex; gap: 0; margin-bottom: 24px; }
  .tab {
    flex: 1; padding: 10px; text-align: center; cursor: pointer;
    border-bottom: 2px solid transparent; color: var(--muted); font-size: 14px;
    font-weight: 500; transition: all 0.15s;
  }
  .tab.active { border-bottom-color: var(--accent); color: var(--text); }
  .tab:hover { color: var(--text); }
  .hidden { display: none; }
  .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 0.6s linear infinite; margin-right: 6px; vertical-align: middle; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .connect-prompt { text-align: center; padding: 40px 0; color: var(--muted); }
  .preset-row { display: flex; gap: 6px; margin-bottom: 8px; }
  .preset { background: var(--bg); border: 1px solid var(--border); color: var(--muted); padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; flex: 1; }
  .preset:hover { border-color: var(--accent); color: var(--text); }
  .preset.active { border-color: var(--accent); color: var(--accent); background: rgba(108,92,231,0.1); }
  .token-balance { font-size: 12px; color: var(--muted); margin-top: 4px; }
  .token-balance .bal { color: var(--text); font-family: monospace; }
  .token-row { display: flex; gap: 8px; align-items: center; }
  .token-row select { flex: 1; }
  .token-row .add-token-btn { padding: 10px 14px; font-size: 13px; white-space: nowrap; flex-shrink: 0; }
  .hint { font-size: 12px; color: var(--muted); margin-top: 4px; }
  .approval-status { font-size: 12px; margin-top: 4px; }
  .approval-ok { color: var(--green); }
  .approval-need { color: var(--orange); }
  .bond-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 14px; border: 1px solid var(--border); border-radius: 8px;
    margin-bottom: 8px; cursor: pointer; transition: border-color 0.15s;
  }
  .bond-item:hover { border-color: var(--accent); }
  .bond-item .bi-left { }
  .bond-item .bi-id { font-weight: 600; font-size: 15px; }
  .bond-item .bi-meta { font-size: 12px; color: var(--muted); margin-top: 2px; max-width: 360px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .bond-item .bi-right { text-align: right; }
  .bond-item .bi-amount { font-size: 14px; font-family: monospace; }
  .bond-item .bi-role { font-size: 11px; color: var(--muted); margin-top: 2px; }
  .success-card {
    background: rgba(0,184,148,0.08); border: 1px solid var(--green);
    border-radius: 10px; padding: 20px; text-align: center; margin-top: 16px;
  }
  .success-card .sc-id { font-size: 28px; font-weight: 700; color: var(--green); }
  .success-card .sc-label { font-size: 13px; color: var(--muted); margin-bottom: 4px; }
  .success-card .sc-actions { margin-top: 14px; display: flex; gap: 8px; justify-content: center; }
  .success-card .sc-actions button { flex: none; }
  .challenge-queue { margin-top: 16px; }
  .challenge-queue h3 { font-size: 14px; font-weight: 600; margin-bottom: 8px; }
  .challenge-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px;
    margin-bottom: 6px; font-size: 13px;
  }
  .challenge-item.current { border-color: var(--accent); background: rgba(108,92,231,0.06); }
  .challenge-item .ci-idx { color: var(--muted); margin-right: 8px; font-family: monospace; }
  .challenge-item .ci-addr { font-family: monospace; }
  .amounts-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
  footer { text-align: center; padding: 24px 0; color: var(--muted); font-size: 12px; border-top: 1px solid var(--border); margin-top: 32px; }
  footer a { color: var(--accent); text-decoration: none; }

  /* ─── Connection Screen ─── */
  .connect-screen {
    text-align: center; padding: 60px 20px;
  }
  .connect-screen h2 {
    font-size: 28px; font-weight: 700; margin-bottom: 8px;
    background: linear-gradient(135deg, var(--accent), var(--blue));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .connect-screen .subtitle {
    color: var(--muted); font-size: 15px; margin-bottom: 32px; max-width: 380px; margin-inline: auto;
  }
  .connect-options { display: flex; flex-direction: column; gap: 12px; max-width: 340px; margin: 0 auto; }
  .connect-option {
    padding: 14px 20px; border-radius: 10px; cursor: pointer;
    font-size: 15px; font-weight: 500; text-align: center; transition: all 0.15s;
  }
  .connect-option-primary {
    background: var(--accent); color: #fff; border: none;
  }
  .connect-option-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
  .connect-option-secondary {
    background: var(--surface); color: var(--text); border: 1px solid var(--border);
  }
  .connect-option-secondary:hover { border-color: var(--muted); }
  .connect-screen .browse-link {
    margin-top: 20px; font-size: 13px; color: var(--muted); cursor: pointer;
    text-decoration: underline;
  }
  .connect-screen .browse-link:hover { color: var(--text); }

  /* ─── Simple/Advanced Mode Toggle ─── */
  .mode-toggle {
    display: flex; background: var(--bg); border-radius: 8px;
    border: 1px solid var(--border); overflow: hidden; margin-bottom: 20px;
  }
  .mode-btn {
    flex: 1; padding: 8px 16px; text-align: center; cursor: pointer;
    font-size: 13px; font-weight: 500; color: var(--muted);
    background: transparent; border: none; transition: all 0.15s;
  }
  .mode-btn.active {
    background: var(--accent); color: #fff;
  }
  .mode-btn:hover:not(.active) { color: var(--text); }
  .advanced-field { display: none; }
  .advanced-field.show { display: block; }

  /* ─── Funding Banner ─── */
  .funding-banner {
    background: rgba(108,92,231,0.08); border: 1px solid rgba(108,92,231,0.25);
    border-radius: 10px; padding: 16px; margin-bottom: 20px;
  }
  .funding-banner h3 { font-size: 14px; margin-bottom: 6px; }
  .funding-banner p { font-size: 13px; color: var(--muted); margin-bottom: 10px; }
  .funding-banner .funding-actions { display: flex; gap: 8px; }
  .funding-banner .funding-actions button { font-size: 13px; padding: 8px 14px; }
  .funding-state-none { border-color: rgba(231,76,60,0.3); background: rgba(231,76,60,0.06); }
  .funding-state-convert { border-color: rgba(243,156,18,0.3); background: rgba(243,156,18,0.06); }

  /* ─── Transaction Stepper ─── */
  .tx-stepper {
    display: flex; flex-direction: column; gap: 0; margin: 16px 0;
    background: var(--bg); border-radius: 10px; padding: 16px; border: 1px solid var(--border);
  }
  .tx-step {
    display: flex; align-items: center; gap: 12px; padding: 10px 0;
    position: relative; color: var(--muted); font-size: 13px;
  }
  .tx-step:not(:last-child)::after {
    content: ''; position: absolute; left: 13px; top: 38px;
    width: 2px; height: calc(100% - 18px); background: var(--border);
  }
  .tx-step .step-num {
    width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
    background: var(--surface); border: 2px solid var(--border); font-size: 12px; font-weight: 600;
    flex-shrink: 0; z-index: 1;
  }
  .tx-step.tx-step-active { color: var(--text); }
  .tx-step.tx-step-active .step-num {
    border-color: var(--accent); color: var(--accent);
  }
  .tx-step.tx-step-active .step-num .spinner {
    width: 14px; height: 14px; margin: 0; border-width: 2px;
    border-color: rgba(108,92,231,0.3); border-top-color: var(--accent);
  }
  .tx-step.tx-step-done { color: var(--green); }
  .tx-step.tx-step-done .step-num {
    background: var(--green); border-color: var(--green); color: #fff;
  }
  .tx-step.tx-step-done::after { background: var(--green); }
  .tx-step .step-label { flex: 1; }

  /* ─── Browse Bonds ─── */
  .bond-browse-item {
    background: var(--bg); border: 1px solid var(--border); border-radius: 10px;
    padding: 16px; margin-bottom: 10px; cursor: pointer; transition: all 0.15s;
  }
  .bond-browse-item:hover { border-color: var(--accent); transform: translateY(-1px); }
  .bond-browse-item .bb-desc {
    font-size: 14px; font-weight: 500; margin-bottom: 8px;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
  }
  .bond-browse-stats {
    display: flex; gap: 16px; flex-wrap: wrap; font-size: 12px; color: var(--muted);
  }
  .bond-browse-stats .stat-val { color: var(--text); font-weight: 500; }
  .countdown { color: var(--orange); font-weight: 500; }

  /* ─── Risk/Reward Card ─── */
  .risk-reward-card {
    background: var(--bg); border: 1px solid var(--border); border-radius: 10px;
    padding: 20px; margin-top: 16px;
  }
  .risk-reward-card h3 { font-size: 15px; font-weight: 600; margin-bottom: 12px; }
  .risk-reward-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
  .reward-item {
    background: rgba(0,184,148,0.08); border: 1px solid rgba(0,184,148,0.2);
    border-radius: 8px; padding: 12px; text-align: center;
  }
  .reward-item .rr-label { font-size: 11px; color: var(--green); text-transform: uppercase; letter-spacing: 0.5px; }
  .reward-item .rr-value { font-size: 20px; font-weight: 700; color: var(--green); margin-top: 4px; }
  .risk-item {
    background: rgba(231,76,60,0.08); border: 1px solid rgba(231,76,60,0.2);
    border-radius: 8px; padding: 12px; text-align: center;
  }
  .risk-item .rr-label { font-size: 11px; color: var(--red); text-transform: uppercase; letter-spacing: 0.5px; }
  .risk-item .rr-value { font-size: 20px; font-weight: 700; color: var(--red); margin-top: 4px; }
  .risk-reward-card .rr-note { font-size: 12px; color: var(--muted); margin-bottom: 14px; }

  /* ─── Transak Overlay ─── */
  .transak-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.75); z-index: 1000;
    display: flex; align-items: center; justify-content: center;
  }
  .transak-iframe-container {
    background: #fff; border-radius: 16px; overflow: hidden;
    width: 420px; max-width: 95vw; height: 620px; max-height: 90vh;
    position: relative;
  }
  .transak-iframe-container iframe {
    width: 100%; height: 100%; border: none;
  }
  .transak-close {
    position: absolute; top: 8px; right: 12px; z-index: 10;
    background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 50%;
    width: 32px; height: 32px; font-size: 18px; cursor: pointer; display: flex;
    align-items: center; justify-content: center;
  }

  /* ─── Copy Address Button ─── */
  .copy-addr-btn {
    background: none; border: 1px solid var(--border); color: var(--muted);
    padding: 6px 12px; font-size: 12px; border-radius: 6px; cursor: pointer;
  }
  .copy-addr-btn:hover { border-color: var(--accent); color: var(--text); }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>SimpleBond <span>by Futarchy</span></h1>
    <div>
      <div id="walletInfo" class="wallet-info hidden">
        <div class="address" id="walletAddr"></div>
        <div class="chain" id="chainName"></div>
        <div class="disconnect-link" onclick="disconnectWallet()">Sign out</div>
      </div>
      <button id="connectBtn" class="hidden" onclick="showConnectScreen()">Sign In</button>
    </div>
  </header>

  <!-- CONNECTION SCREEN -->
  <div id="connectScreen" class="connect-screen">
    <h2>Put your money where your mouth is</h2>
    <p class="subtitle">Create and challenge bonds with real stakes. No crypto experience needed.</p>
    <div class="connect-options">
      <button class="connect-option connect-option-primary" onclick="connectWeb3Auth()">
        Sign in with Google or Email
      </button>
      <button class="connect-option connect-option-secondary" onclick="connectInjectedWallet()">
        Connect Existing Wallet
      </button>
    </div>
    <div class="browse-link" onclick="browseWithoutWallet()">Browse active bonds without signing in</div>
  </div>

  <!-- MAIN APP (hidden until connected or browsing) -->
  <div id="mainApp" class="hidden">
    <div class="tabs">
      <div class="tab active" data-tab="create" onclick="switchTab('create')">Create Bond</div>
      <div class="tab" data-tab="browse" onclick="switchTab('browse')">Browse Bonds</div>
      <div class="tab" data-tab="my" onclick="switchTab('my')">My Bonds</div>
      <div class="tab" data-tab="view" onclick="switchTab('view')">View Bond</div>
    </div>

    <!-- CREATE BOND -->
    <div id="tab-create" class="card">
      <h2>Create a Bond</h2>
      <div id="createConnectPrompt" class="connect-prompt">Sign in to create a bond.</div>
      <div id="createForm" class="hidden">
        <!-- Funding Banner -->
        <div id="fundingBanner" class="funding-banner hidden"></div>

        <!-- Simple / Advanced Toggle -->
        <div class="mode-toggle">
          <button class="mode-btn active" data-mode="simple" onclick="setMode('simple')">Simple</button>
          <button class="mode-btn" data-mode="advanced" onclick="setMode('advanced')">Advanced</button>
        </div>

        <div class="form-group">
          <label>Amount (USD)</label>
          <input type="text" id="bondAmount" placeholder="100.00" oninput="onAmountChange()">
          <div id="tokenBalanceInfo" class="token-balance"></div>
          <div id="approvalStatus" class="approval-status"></div>
        </div>

        <div class="form-group">
          <label>What is this bond for?</label>
          <textarea id="bondMetadata" placeholder="e.g. &quot;I bet $100 that Bitcoin hits $200k by June 2026&quot;" rows="2"></textarea>
        </div>

        <div class="form-group">
          <label>Judge address</label>
          <input type="text" id="judgeAddr" placeholder="0x... (the person who decides disputes)">
          <div class="hint">The judge rules on challenges. Pick someone both parties trust.</div>
        </div>

        <div class="form-group">
          <label>Deadline</label>
          <div class="preset-row">
            <button type="button" class="preset" data-days="30" onclick="setDeadline(30)">1 month</button>
            <button type="button" class="preset" data-days="90" onclick="setDeadline(90)">3 months</button>
            <button type="button" class="preset" data-days="180" onclick="setDeadline(180)">6 months</button>
            <button type="button" class="preset" data-days="365" onclick="setDeadline(365)">1 year</button>
          </div>
          <input type="date" id="deadline">
          <div class="hint">Challenges accepted before this date.</div>
        </div>

        <!-- Advanced fields -->
        <div class="form-group advanced-field" id="advTokenField">
          <label>Currency</label>
          <div class="token-row">
            <select id="tokenSelect" onchange="onTokenChange()"></select>
            <button type="button" class="secondary add-token-btn" onclick="addCustomToken()">+ Add Custom</button>
          </div>
        </div>

        <div class="form-group advanced-field" id="advChallengeField">
          <label>Challenge Amount</label>
          <input type="text" id="challengeAmount" placeholder="50.0">
          <div class="hint">Amount each challenger must deposit. Default: 50% of bond.</div>
        </div>

        <div class="form-group advanced-field" id="advJudgeFeeField">
          <label>Judge Fee</label>
          <input type="text" id="judgeFee" placeholder="10.0">
          <div class="hint">Fixed fee paid to the judge per ruling. Default: 5% of bond.</div>
        </div>

        <div class="form-group advanced-field" id="advRulingBufferField">
          <label>Ruling Buffer</label>
          <div class="preset-row">
            <button type="button" class="preset ruling-preset" data-buffer="7" onclick="setRulingBuffer(7)">7 days</button>
            <button type="button" class="preset ruling-preset" data-buffer="14" onclick="setRulingBuffer(14)">14 days</button>
            <button type="button" class="preset ruling-preset active" data-buffer="30" onclick="setRulingBuffer(30)">30 days</button>
          </div>
          <div class="hint">Time after deadline for the judge to rule. Default: 30 days.</div>
        </div>

        <div id="createStepper"></div>

        <button id="createBtn" onclick="smartCreateBond()" style="width:100%;margin-top:16px;">Create Bond</button>
        <div id="createMsg"></div>
      </div>
    </div>

    <!-- BROWSE BONDS -->
    <div id="tab-browse" class="card hidden">
      <h2>Active Bonds</h2>
      <div id="browseLoading" style="color:var(--muted);text-align:center;padding:20px;">
        <span class="spinner"></span> Loading active bonds...
      </div>
      <div id="browseBondsList"></div>
      <div id="browseEmpty" class="hidden" style="text-align:center;padding:20px;color:var(--muted);">
        No active bonds found.
      </div>
    </div>

    <!-- MY BONDS -->
    <div id="tab-my" class="card hidden">
      <h2>My Bonds</h2>
      <div id="myBondsConnect" class="connect-prompt">Sign in to see your bonds.</div>
      <div id="myBondsContent" class="hidden">
        <div id="myBondsLoading" style="color:var(--muted);text-align:center;padding:20px;">
          <span class="spinner"></span> Loading your bonds...
        </div>
        <div id="myBondsList"></div>
        <div id="myBondsEmpty" class="hidden" style="text-align:center;padding:20px;color:var(--muted);">
          No bonds found. Create one above!
        </div>
      </div>
    </div>

    <!-- VIEW BOND -->
    <div id="tab-view" class="card hidden">
      <h2>View a Bond</h2>
      <div style="display:flex;gap:8px;margin-bottom:16px;">
        <input type="number" id="bondIdInput" placeholder="Bond ID (e.g. 0)" min="0" style="flex:1">
        <button class="secondary" onclick="loadBond()">Load</button>
      </div>
      <div id="bondDisplay" class="hidden">
        <div class="bond-detail">
          <div class="bond-field">
            <div class="label">Bond ID</div>
            <div class="value" id="bId"></div>
          </div>
          <div class="bond-field">
            <div class="label">Status</div>
            <div class="value" id="bStatus"></div>
          </div>
          <div class="bond-field full">
            <div class="label">Poster</div>
            <div class="value"><a id="bPoster" target="_blank"></a></div>
          </div>
          <div class="bond-field full">
            <div class="label">Judge</div>
            <div class="value"><a id="bJudge" target="_blank"></a></div>
          </div>
          <div class="bond-field full">
            <div class="label">Currency</div>
            <div class="value"><a id="bToken" target="_blank"></a></div>
          </div>
        </div>
        <div class="amounts-grid" style="margin-top:12px;">
          <div class="bond-field">
            <div class="label">Bond Amount</div>
            <div class="value" id="bBondAmount"></div>
          </div>
          <div class="bond-field">
            <div class="label">Challenge Cost</div>
            <div class="value" id="bChallengeAmount"></div>
          </div>
          <div class="bond-field">
            <div class="label">Judge Fee</div>
            <div class="value" id="bJudgeFee"></div>
          </div>
        </div>
        <div class="bond-detail" style="margin-top:12px;">
          <div class="bond-field">
            <div class="label">Challenge Deadline</div>
            <div class="value" id="bDeadline"></div>
          </div>
          <div class="bond-field">
            <div class="label">Ruling Deadline</div>
            <div class="value" id="bRulingDeadline"></div>
          </div>
          <div class="bond-field full" id="bMetadataRow">
            <div class="label">Description</div>
            <div class="value" id="bMetadata" style="white-space:pre-wrap;"></div>
          </div>
        </div>

        <!-- Risk/Reward Card (for challengers) -->
        <div id="riskRewardCard" class="risk-reward-card hidden">
          <h3>Challenge this Bond</h3>
          <div class="risk-reward-grid">
            <div class="reward-item">
              <div class="rr-label">If you win</div>
              <div class="rr-value" id="rrWinAmount"></div>
            </div>
            <div class="risk-item">
              <div class="rr-label">Your risk</div>
              <div class="rr-value" id="rrRiskAmount"></div>
            </div>
          </div>
          <div class="rr-note" id="rrNote"></div>
          <div id="challengeStepper"></div>
          <button id="challengeBtn" onclick="smartChallengeBond()" style="width:100%;">Challenge This Bond</button>
          <div id="challengeMsg"></div>
        </div>

        <!-- Challenge Queue -->
        <div id="challengeQueueSection" class="challenge-queue hidden">
          <h3>Challenge Queue</h3>
          <div id="challengeList"></div>
        </div>

        <div id="bondActions" class="actions hidden">
          <div class="btn-row" id="actionBtns"></div>
        </div>
        <div id="viewMsg"></div>
      </div>
    </div>
  </div>

  <!-- Transak Overlay -->
  <div id="transakOverlay" class="transak-overlay hidden">
    <div class="transak-iframe-container">
      <button class="transak-close" onclick="closeTransak()">&times;</button>
      <iframe id="transakIframe"></iframe>
    </div>
  </div>

  <footer>
    <a href="https://github.com/futarchy-fi/simple-bond" target="_blank">GitHub</a>
    &nbsp;&middot;&nbsp; Gnosis Chain
  </footer>
</div>

<script>
// ─── Config ───────────────────────────────────────────────────────────
const CONTRACT_ADDRESS = "0xfB3623bd169E5D3dB275BB0644219a5aBA73108D";
const CONTRACT_DEPLOY_BLOCK = 44914900;
const GNOSIS_CHAIN_ID = 100n;
const GNOSIS_RPC = "https://rpc.gnosischain.com";
const GNOSISSCAN = "https://gnosisscan.io/address/";

// ─── TODO: Register at dashboard.web3auth.io and paste your clientId ──
const WEB3AUTH_CLIENT_ID = "BNKsZatxbOQKhvr2Q10vDSn0_dDyUXdMgUVUE1xeixa1xKKjIOFZZC3Al0hsyfhwDb_A-rrPobh3sQYhnNfDkEY";

// ─── TODO: Register at dashboard.transak.com and paste your API key ───
const TRANSAK_API_KEY = "YOUR_TRANSAK_API_KEY";

// ─── Token Addresses ──────────────────────────────────────────────────
const SDAI_ADDRESS  = "0xaf204776c7245bF4147c2612BF6e5972Ee483701";
const WXDAI_ADDRESS = "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d";

const DEFAULT_TOKENS = [
  { address: SDAI_ADDRESS, symbol: "sDAI", decimals: 18 },
  { address: WXDAI_ADDRESS, symbol: "WXDAI", decimals: 18 },
];

// Human-friendly token names
const TOKEN_DISPLAY_NAMES = {
  [SDAI_ADDRESS.toLowerCase()]:  "USD Savings (earns ~8% APY)",
  [WXDAI_ADDRESS.toLowerCase()]: "USD",
};

function friendlyTokenName(addr, symbol) {
  return TOKEN_DISPLAY_NAMES[addr.toLowerCase()] || symbol || "???";
}

// ─── ABIs ─────────────────────────────────────────────────────────────
const BOND_ABI = [
  "function createBond(address token, uint256 bondAmount, uint256 challengeAmount, uint256 judgeFee, address judge, uint256 deadline, uint256 rulingBuffer, string metadata) returns (uint256)",
  "function challenge(uint256 bondId)",
  "function withdrawBond(uint256 bondId)",
  "function ruleForChallenger(uint256 bondId)",
  "function ruleForPoster(uint256 bondId)",
  "function claimTimeout(uint256 bondId)",
  "function bonds(uint256) view returns (address poster, address judge, address token, uint256 bondAmount, uint256 challengeAmount, uint256 judgeFee, uint256 deadline, uint256 rulingDeadline, string metadata, bool settled, uint256 currentChallenge)",
  "function nextBondId() view returns (uint256)",
  "function getChallengeCount(uint256 bondId) view returns (uint256)",
  "function getChallenge(uint256 bondId, uint256 index) view returns (address challenger, uint8 status)",
  "event BondCreated(uint256 indexed bondId, address indexed poster, address indexed judge, address token, uint256 bondAmount, uint256 challengeAmount, uint256 judgeFee, uint256 deadline, uint256 rulingDeadline, string metadata)",
  "event Challenged(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger)",
  "event RuledForChallenger(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger)",
  "event RuledForPoster(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger)",
  "event ChallengeRefunded(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger)",
  "event BondWithdrawn(uint256 indexed bondId)",
  "event BondTimedOut(uint256 indexed bondId)",
];

const ERC20_ABI = [
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
  "function balanceOf(address) view returns (uint256)",
];

const WXDAI_ABI = [
  ...ERC20_ABI,
  "function deposit() payable",
  "function withdraw(uint256 amount)",
];

const SDAI_ABI = [
  ...ERC20_ABI,
  "function deposit(uint256 assets, address receiver) returns (uint256 shares)",
  "function withdraw(uint256 assets, address receiver, address owner) returns (uint256 shares)",
  "function convertToShares(uint256 assets) view returns (uint256)",
  "function convertToAssets(uint256 shares) view returns (uint256)",
];

// ─── State ────────────────────────────────────────────────────────────
let provider, signer, userAddr, bondContract;
let web3authInstance = null;
let web3authProvider = null;
let connectionType = null; // 'web3auth' | 'injected'
let tokenCache = {};
let approvalCheckTimer = null;
let rulingBufferDays = 30;
let currentMode = 'simple';
let currentViewBondId = null;
let currentViewBondData = null;
let myBondsLoaded = false;
let browseBondsLoaded = false;

// ─── Token list (localStorage) ────────────────────────────────────────
function getCustomTokens() {
  try { return JSON.parse(localStorage.getItem("bondCustomTokens") || "[]"); } catch (_) { return []; }
}

function saveCustomToken(token) {
  const list = getCustomTokens();
  if (!list.find(t => t.address.toLowerCase() === token.address.toLowerCase())) {
    list.push(token);
    localStorage.setItem("bondCustomTokens", JSON.stringify(list));
  }
}

function getAllTokens() {
  return [...DEFAULT_TOKENS, ...getCustomTokens()];
}

function buildTokenSelect() {
  const sel = document.getElementById("tokenSelect");
  const prev = sel.value;
  sel.innerHTML = "";
  for (const t of getAllTokens()) {
    const opt = document.createElement("option");
    opt.value = t.address;
    const cached = tokenCache[t.address.toLowerCase()];
    const balStr = cached ? ` (${formatBal(cached.balance, cached.decimals)})` : "";
    opt.textContent = `${friendlyTokenName(t.address, t.symbol)}${balStr}`;
    sel.appendChild(opt);
  }
  if (prev && [...sel.options].some(o => o.value.toLowerCase() === prev.toLowerCase())) {
    sel.value = prev;
  }
}

function formatBal(raw, decimals) {
  if (raw == null) return "...";
  const n = parseFloat(ethers.formatUnits(raw, decimals));
  if (n === 0) return "0";
  if (n < 0.01) return "<0.01";
  return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
}

async function addCustomToken() {
  const addr = prompt("Token contract address (0x...):");
  if (!addr || !ethers.isAddress(addr)) { alert("Invalid address"); return; }
  if (getAllTokens().find(t => t.address.toLowerCase() === addr.toLowerCase())) {
    alert("Token already in list"); return;
  }
  const readProvider = provider || new ethers.JsonRpcProvider(GNOSIS_RPC);
  const token = new ethers.Contract(addr, ERC20_ABI, readProvider);
  let symbol, decimals;
  try {
    [symbol, decimals] = await Promise.all([token.symbol(), token.decimals()]);
    decimals = Number(decimals);
  } catch (_) {
    alert("Could not read token info. Is this a valid ERC-20 on Gnosis Chain?"); return;
  }
  saveCustomToken({ address: addr, symbol, decimals });
  buildTokenSelect();
  document.getElementById("tokenSelect").value = addr;
  onTokenChange();
}

// ─── Token change ─────────────────────────────────────────────────────
async function onTokenChange() {
  const addr = document.getElementById("tokenSelect").value;
  if (!addr) return;
  updateBalanceDisplay(addr);
}

function onAmountChange() {
  checkApproval();
}

async function updateBalanceDisplay(tokenAddr) {
  const el = document.getElementById("tokenBalanceInfo");
  if (!userAddr || !tokenAddr) { el.innerHTML = ""; return; }
  const key = tokenAddr.toLowerCase();
  el.innerHTML = "Loading balance...";
  try {
    const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer || new ethers.JsonRpcProvider(GNOSIS_RPC));
    const [balance, allowance, decimals, symbol] = await Promise.all([
      token.balanceOf(userAddr),
      token.allowance(userAddr, CONTRACT_ADDRESS),
      token.decimals(),
      token.symbol(),
    ]);
    tokenCache[key] = { symbol, decimals: Number(decimals), balance, allowance };
    const bal = formatBal(balance, Number(decimals));
    const display = friendlyTokenName(tokenAddr, symbol);
    el.innerHTML = `Balance: <span class="bal">${bal} ${display}</span>`;
    buildTokenSelect();
    document.getElementById("tokenSelect").value = tokenAddr;
  } catch (err) {
    el.innerHTML = `<span style="color:var(--red)">Could not load balance</span>`;
  }
}

// ─── Auto-check approval ──────────────────────────────────────────────
async function checkApproval() {
  clearTimeout(approvalCheckTimer);
  approvalCheckTimer = setTimeout(_doCheckApproval, 300);
}

async function _doCheckApproval() {
  const statusEl = document.getElementById("approvalStatus");
  const tokenAddr = getSelectedToken();
  const amountStr = document.getElementById("bondAmount").value.trim();

  if (!userAddr || !tokenAddr || !amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) {
    statusEl.innerHTML = "";
    return;
  }

  const key = tokenAddr.toLowerCase();
  let cached = tokenCache[key];

  if (!cached) {
    try {
      const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer || new ethers.JsonRpcProvider(GNOSIS_RPC));
      const [balance, allowance, decimals, symbol] = await Promise.all([
        token.balanceOf(userAddr),
        token.allowance(userAddr, CONTRACT_ADDRESS),
        token.decimals(),
        token.symbol(),
      ]);
      cached = { symbol, decimals: Number(decimals), balance, allowance };
      tokenCache[key] = cached;
    } catch (_) { return; }
  }

  try {
    const amount = ethers.parseUnits(amountStr, cached.decimals);
    if (cached.balance < amount) {
      // Check if user has WXDAI or xDAI that can be wrapped
      const totalAvailable = await getTotalAvailableFunds();
      if (totalAvailable >= amount) {
        statusEl.innerHTML = `<span class="approval-ok">Funds available (will auto-convert)</span>`;
      } else {
        const need = ethers.formatUnits(amount - totalAvailable, 18);
        statusEl.innerHTML = `<span class="approval-need">Need ${parseFloat(need).toLocaleString(undefined, {maximumFractionDigits: 2})} more USD</span>`;
      }
      return;
    }
    if (cached.allowance >= amount) {
      statusEl.innerHTML = `<span class="approval-ok">Ready to create</span>`;
    } else {
      statusEl.innerHTML = `<span class="approval-ok">Will auto-approve</span>`;
    }
  } catch (_) {
    statusEl.innerHTML = "";
  }
}

// ─── Get total available funds across xDAI/WXDAI/sDAI ──────────────
async function getTotalAvailableFunds() {
  if (!userAddr) return 0n;
  const readProv = signer || new ethers.JsonRpcProvider(GNOSIS_RPC);
  try {
    const [nativeBalance, wxdaiContract, sdaiContract] = [
      await (provider || new ethers.JsonRpcProvider(GNOSIS_RPC)).getBalance(userAddr),
      new ethers.Contract(WXDAI_ADDRESS, ERC20_ABI, readProv),
      new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, readProv),
    ];
    const [wxdaiBal, sdaiBal, sdaiAssets] = await Promise.all([
      wxdaiContract.balanceOf(userAddr),
      sdaiContract.balanceOf(userAddr),
      sdaiContract.convertToAssets(await sdaiContract.balanceOf(userAddr)).catch(() => 0n),
    ]);
    // sDAI balance is already in "assets" terms via convertToAssets
    return nativeBalance + wxdaiBal + sdaiAssets;
  } catch (_) {
    return 0n;
  }
}

// ─── Wallet Connection ────────────────────────────────────────────────

function showConnectScreen() {
  document.getElementById("connectScreen").classList.remove("hidden");
  document.getElementById("mainApp").classList.add("hidden");
}

async function initWeb3Auth() {
  if (WEB3AUTH_CLIENT_ID === "YOUR_WEB3AUTH_CLIENT_ID") return null;
  try {
    const { Web3Auth } = window.Modal || window.Web3auth?.Modal || {};
    if (!Web3Auth) {
      console.warn("Web3Auth Modal not loaded from CDN");
      return null;
    }
    const web3auth = new Web3Auth({
      clientId: WEB3AUTH_CLIENT_ID,
      web3AuthNetwork: "sapphire_devnet",
      chainConfig: {
        chainNamespace: "eip155",
        chainId: "0x64",
        rpcTarget: GNOSIS_RPC,
        displayName: "Gnosis Chain",
        blockExplorerUrl: "https://gnosisscan.io",
        ticker: "XDAI",
        tickerName: "xDAI",
      },
      uiConfig: {
        theme: "dark",
        appName: "SimpleBond",
      },
    });
    await web3auth.initModal();
    web3authInstance = web3auth;
    return web3auth;
  } catch (err) {
    console.warn("Web3Auth init failed:", err);
    return null;
  }
}

async function connectWeb3Auth() {
  try {
    if (!web3authInstance) {
      const inst = await initWeb3Auth();
      if (!inst) {
        alert("Web3Auth is not configured yet. Please set WEB3AUTH_CLIENT_ID in the page source, or use 'Connect Existing Wallet'.");
        return;
      }
    }
    const w3aProvider = await web3authInstance.connect();
    if (!w3aProvider) return;
    web3authProvider = w3aProvider;
    connectionType = 'web3auth';
    provider = new ethers.BrowserProvider(w3aProvider);
    signer = await provider.getSigner();
    userAddr = await signer.getAddress();
    bondContract = new ethers.Contract(CONTRACT_ADDRESS, BOND_ABI, signer);
    onWalletConnected();
  } catch (err) {
    console.error("Web3Auth connect error:", err);
    if (err.message && !err.message.includes("User closed")) {
      alert("Sign-in failed: " + (err.message || err));
    }
  }
}

async function connectInjectedWallet() {
  if (!window.ethereum) {
    alert("No wallet detected. Install MetaMask or Rabby to use this option.");
    return;
  }
  try {
    await window.ethereum.request({ method: "eth_requestAccounts" });
    provider = new ethers.BrowserProvider(window.ethereum);
    const network = await provider.getNetwork();
    if (network.chainId !== GNOSIS_CHAIN_ID) {
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: "0x64" }],
        });
      } catch (switchErr) {
        if (switchErr.code === 4902) {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: "0x64",
              chainName: "Gnosis Chain",
              nativeCurrency: { name: "xDAI", symbol: "XDAI", decimals: 18 },
              rpcUrls: [GNOSIS_RPC],
              blockExplorerUrls: ["https://gnosisscan.io"],
            }],
          });
        } else { throw switchErr; }
      }
      provider = new ethers.BrowserProvider(window.ethereum);
    }
    signer = await provider.getSigner();
    userAddr = await signer.getAddress();
    connectionType = 'injected';
    bondContract = new ethers.Contract(CONTRACT_ADDRESS, BOND_ABI, signer);
    onWalletConnected();
  } catch (err) {
    console.error("Injected wallet error:", err);
    alert("Connection failed: " + (err.message || err));
  }
}

function onWalletConnected() {
  document.getElementById("connectScreen").classList.add("hidden");
  document.getElementById("mainApp").classList.remove("hidden");
  document.getElementById("connectBtn").classList.add("hidden");
  document.getElementById("walletInfo").classList.remove("hidden");
  document.getElementById("walletAddr").textContent = short(userAddr);
  document.getElementById("chainName").textContent = "Gnosis Chain";
  document.getElementById("createConnectPrompt").classList.add("hidden");
  document.getElementById("createForm").classList.remove("hidden");
  document.getElementById("myBondsConnect").classList.add("hidden");
  document.getElementById("myBondsContent").classList.remove("hidden");

  if (!document.getElementById("deadline").value) {
    const d = new Date(Date.now() + 90 * 86400000);
    document.getElementById("deadline").value = d.toISOString().slice(0, 10);
  }

  tokenCache = {};
  refreshAllBalances().then(() => {
    checkOnboardingState();
  });

  // Set up injected wallet event listeners
  if (connectionType === 'injected' && window.ethereum) {
    window.ethereum.on("accountsChanged", () => { saveForm(); window.location.reload(); });
    window.ethereum.on("chainChanged", () => { saveForm(); window.location.reload(); });
  }
}

async function disconnectWallet() {
  if (connectionType === 'web3auth' && web3authInstance) {
    try { await web3authInstance.logout(); } catch (_) {}
    web3authProvider = null;
  }
  provider = null;
  signer = null;
  userAddr = null;
  bondContract = null;
  connectionType = null;
  tokenCache = {};
  myBondsLoaded = false;

  document.getElementById("walletInfo").classList.add("hidden");
  document.getElementById("connectBtn").classList.remove("hidden");
  document.getElementById("connectScreen").classList.remove("hidden");
  document.getElementById("mainApp").classList.add("hidden");
}

function browseWithoutWallet() {
  document.getElementById("connectScreen").classList.add("hidden");
  document.getElementById("mainApp").classList.remove("hidden");
  document.getElementById("connectBtn").classList.remove("hidden");
  switchTab("browse");
}

// ─── Onboarding State Machine ─────────────────────────────────────────
async function checkOnboardingState() {
  if (!userAddr) return;
  const banner = document.getElementById("fundingBanner");

  try {
    const readProv = provider || new ethers.JsonRpcProvider(GNOSIS_RPC);
    const nativeBal = await readProv.getBalance(userAddr);
    const wxdai = new ethers.Contract(WXDAI_ADDRESS, ERC20_ABI, signer || readProv);
    const sdai = new ethers.Contract(SDAI_ADDRESS, ERC20_ABI, signer || readProv);
    const [wxdaiBal, sdaiBal] = await Promise.all([
      wxdai.balanceOf(userAddr),
      sdai.balanceOf(userAddr),
    ]);

    const hasNative = nativeBal > ethers.parseEther("0.01");
    const hasWxdai = wxdaiBal > ethers.parseEther("0.01");
    const hasSdai = sdaiBal > ethers.parseEther("0.01");

    if (hasSdai) {
      // Ready to go
      banner.classList.add("hidden");
      return;
    }

    if (hasNative || hasWxdai) {
      // Has funds but not in sDAI
      banner.className = "funding-banner funding-state-convert";
      banner.classList.remove("hidden");
      const wxdaiAmt = formatBal(wxdaiBal, 18);
      const nativeAmt = formatBal(nativeBal, 18);
      banner.innerHTML = `
        <h3>Convert to earn yield!</h3>
        <p>You have ${hasWxdai ? wxdaiAmt + ' WXDAI' : ''}${hasWxdai && hasNative ? ' + ' : ''}${hasNative ? nativeAmt + ' xDAI' : ''}.
           Convert to USD Savings to earn ~8% APY while your bond is active.</p>
        <div class="funding-actions">
          <button onclick="convertAllToSdai()">Convert to USD Savings</button>
        </div>`;
      return;
    }

    // No funds at all
    banner.className = "funding-banner funding-state-none";
    banner.classList.remove("hidden");
    banner.innerHTML = `
      <h3>You need funds to create bonds</h3>
      <p>Buy USD with a credit card, or send xDAI to your wallet address.</p>
      <div class="funding-actions">
        <button onclick="openTransak()">Buy with Credit Card</button>
        <button class="copy-addr-btn" onclick="copyAddress()">Copy Wallet Address</button>
      </div>`;
  } catch (err) {
    console.warn("Onboarding check failed:", err);
    banner.classList.add("hidden");
  }
}

function copyAddress() {
  if (!userAddr) return;
  navigator.clipboard.writeText(userAddr).then(() => {
    const btn = event.target;
    const orig = btn.textContent;
    btn.textContent = "Copied!";
    setTimeout(() => { btn.textContent = orig; }, 1500);
  }).catch(() => { prompt("Copy your wallet address:", userAddr); });
}

async function convertAllToSdai() {
  if (!signer || !userAddr) return;
  const banner = document.getElementById("fundingBanner");
  const stepperEl = document.createElement("div");
  banner.innerHTML = "";
  banner.appendChild(stepperEl);

  try {
    const readProv = provider || new ethers.JsonRpcProvider(GNOSIS_RPC);
    const nativeBal = await readProv.getBalance(userAddr);
    const wxdaiContract = new ethers.Contract(WXDAI_ADDRESS, WXDAI_ABI, signer);
    const sdaiContract = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, signer);
    const wxdaiBal = await wxdaiContract.balanceOf(userAddr);

    const steps = [];
    let wxdaiToDeposit = wxdaiBal;

    // Keep 0.01 xDAI for gas
    const gasReserve = ethers.parseEther("0.01");
    const wrapAmount = nativeBal > gasReserve ? nativeBal - gasReserve : 0n;

    if (wrapAmount > 0n) {
      steps.push("Wrap xDAI to WXDAI");
    }
    steps.push("Approve WXDAI");
    steps.push("Deposit to USD Savings");

    renderTxStepper(stepperEl, steps);
    let stepIdx = 0;

    // Step: Wrap xDAI
    if (wrapAmount > 0n) {
      updateStepStatus(stepperEl, stepIdx, 'active');
      const wrapTx = await wxdaiContract.deposit({ value: wrapAmount });
      await wrapTx.wait();
      wxdaiToDeposit += wrapAmount;
      updateStepStatus(stepperEl, stepIdx, 'done');
      stepIdx++;
    }

    // Step: Approve WXDAI for sDAI vault
    updateStepStatus(stepperEl, stepIdx, 'active');
    await ensureApproval(WXDAI_ADDRESS, wxdaiToDeposit, SDAI_ADDRESS);
    updateStepStatus(stepperEl, stepIdx, 'done');
    stepIdx++;

    // Step: Deposit to sDAI
    updateStepStatus(stepperEl, stepIdx, 'active');
    const depositTx = await sdaiContract.deposit(wxdaiToDeposit, userAddr);
    await depositTx.wait();
    updateStepStatus(stepperEl, stepIdx, 'done');

    // Refresh
    tokenCache = {};
    await refreshAllBalances();
    banner.classList.add("hidden");
    showMsg(document.getElementById("createMsg"), "Converted to USD Savings! Ready to create bonds.", "success");
  } catch (err) {
    banner.innerHTML = `<div class="msg msg-error">Conversion failed: ${err.reason || err.message}</div>`;
  }
}

// ─── Transak On-Ramp ──────────────────────────────────────────────────
function openTransak() {
  if (TRANSAK_API_KEY === "YOUR_TRANSAK_API_KEY") {
    alert("Transak is not configured yet. Set TRANSAK_API_KEY in the page source.");
    return;
  }
  const overlay = document.getElementById("transakOverlay");
  const iframe = document.getElementById("transakIframe");
  const addr = userAddr || "";
  iframe.src = `https://global.transak.com/?apiKey=${TRANSAK_API_KEY}&cryptoCurrencyCode=XDAI&network=gnosis&walletAddress=${addr}&themeColor=6c5ce7&hideMenu=true`;
  overlay.classList.remove("hidden");

  // Listen for Transak events
  window.addEventListener("message", handleTransakMessage);
}

function closeTransak() {
  const overlay = document.getElementById("transakOverlay");
  const iframe = document.getElementById("transakIframe");
  iframe.src = "";
  overlay.classList.add("hidden");
  window.removeEventListener("message", handleTransakMessage);
  // Refresh balances after closing
  if (userAddr) {
    tokenCache = {};
    refreshAllBalances().then(() => checkOnboardingState());
  }
}

function handleTransakMessage(event) {
  if (event.data && event.data.event_id === "TRANSAK_ORDER_SUCCESSFUL") {
    closeTransak();
  }
}

// ─── Simple/Advanced Mode ─────────────────────────────────────────────
function setMode(mode) {
  currentMode = mode;
  document.querySelectorAll(".mode-btn").forEach(b => b.classList.toggle("active", b.dataset.mode === mode));
  document.querySelectorAll(".advanced-field").forEach(el => {
    el.classList.toggle("show", mode === "advanced");
  });
  // In simple mode, default token to sDAI
  if (mode === 'simple') {
    document.getElementById("tokenSelect").value = SDAI_ADDRESS;
    onTokenChange();
  }
  sessionStorage.setItem("bondMode", mode);
}

function getSelectedToken() {
  if (currentMode === 'simple') return SDAI_ADDRESS;
  return document.getElementById("tokenSelect").value || SDAI_ADDRESS;
}

// ─── Transaction Stepper ──────────────────────────────────────────────
function renderTxStepper(container, steps) {
  container.innerHTML = `<div class="tx-stepper">${steps.map((label, i) =>
    `<div class="tx-step" data-step="${i}">
      <div class="step-num">${i + 1}</div>
      <div class="step-label">${label}</div>
    </div>`
  ).join("")}</div>`;
}

function updateStepStatus(container, idx, status) {
  const step = container.querySelector(`[data-step="${idx}"]`);
  if (!step) return;
  step.className = `tx-step tx-step-${status}`;
  const numEl = step.querySelector(".step-num");
  if (status === 'active') {
    numEl.innerHTML = '<span class="spinner"></span>';
  } else if (status === 'done') {
    numEl.innerHTML = '\u2713';
  }
}

// ─── Token Wrapping Helpers ───────────────────────────────────────────
async function wrapXdaiToWxdai(amount) {
  const wxdai = new ethers.Contract(WXDAI_ADDRESS, WXDAI_ABI, signer);
  const tx = await wxdai.deposit({ value: amount });
  await tx.wait();
}

async function wrapWxdaiToSdai(amount) {
  const sdai = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, signer);
  const tx = await sdai.deposit(amount, userAddr);
  await tx.wait();
}

async function ensureApproval(tokenAddr, amount, spender) {
  const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
  const allowance = await token.allowance(userAddr, spender);
  if (allowance >= amount) return;
  const tx = await token.approve(spender, amount);
  await tx.wait();
  // Update cache
  const key = tokenAddr.toLowerCase();
  if (tokenCache[key]) {
    tokenCache[key].allowance = await token.allowance(userAddr, spender);
  }
}

async function getBalance(tokenAddr) {
  const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer || new ethers.JsonRpcProvider(GNOSIS_RPC));
  return await token.balanceOf(userAddr);
}

function buildTxSteps(tokenAddr, amountWei) {
  // Returns an array of step descriptors
  // This is determined dynamically when smartCreateBond runs
  return []; // Placeholder — actual logic in smartCreateBond
}

// ─── Smart Create Bond (with stepper) ─────────────────────────────────
async function smartCreateBond() {
  if (!signer) return;
  const btn = document.getElementById("createBtn");
  const msg = document.getElementById("createMsg");
  const stepperEl = document.getElementById("createStepper");

  try {
    const tokenAddr = getSelectedToken();
    if (!ethers.isAddress(tokenAddr)) { showMsg(msg, "Invalid currency", "error"); return; }

    const bondAmountStr = document.getElementById("bondAmount").value.trim();
    if (!bondAmountStr || isNaN(bondAmountStr) || parseFloat(bondAmountStr) <= 0) {
      showMsg(msg, "Enter a valid amount", "error"); return;
    }

    const judgeAddr = document.getElementById("judgeAddr").value.trim();
    if (!ethers.isAddress(judgeAddr)) { showMsg(msg, "Enter a valid judge address", "error"); return; }

    const deadlineStr = document.getElementById("deadline").value;
    if (!deadlineStr) { showMsg(msg, "Set a deadline", "error"); return; }

    // Get or auto-calculate values
    let challengeAmountStr, judgeFeeStr;
    if (currentMode === 'simple') {
      const bondVal = parseFloat(bondAmountStr);
      challengeAmountStr = (bondVal * 0.5).toString();
      judgeFeeStr = (bondVal * 0.05).toString();
    } else {
      challengeAmountStr = document.getElementById("challengeAmount").value.trim();
      judgeFeeStr = document.getElementById("judgeFee").value.trim();
    }

    if (!challengeAmountStr || isNaN(challengeAmountStr) || parseFloat(challengeAmountStr) <= 0) {
      showMsg(msg, "Enter a valid challenge amount", "error"); return;
    }
    if (!judgeFeeStr || isNaN(judgeFeeStr) || parseFloat(judgeFeeStr) < 0) {
      showMsg(msg, "Enter a valid judge fee", "error"); return;
    }

    // Determine decimals
    const tokenContract = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
    const decimals = Number(await tokenContract.decimals());
    const bondAmount = ethers.parseUnits(bondAmountStr, decimals);
    const challengeAmount = ethers.parseUnits(challengeAmountStr, decimals);
    const judgeFee = ethers.parseUnits(judgeFeeStr, decimals);
    const deadline = BigInt(Math.floor(new Date(deadlineStr + "T23:59:59Z").getTime() / 1000));
    const rulingBuffer = BigInt(rulingBufferDays * 86400);

    if (deadline <= BigInt(Math.floor(Date.now() / 1000))) {
      showMsg(msg, "Deadline must be in the future", "error"); return;
    }
    if (judgeFee >= bondAmount + challengeAmount) {
      showMsg(msg, "Judge fee must be less than bond + challenge amount", "error"); return;
    }
    if (judgeFee > challengeAmount) {
      showMsg(msg, "Judge fee must be <= challenge amount", "error"); return;
    }

    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Processing...';

    // Build dynamic steps based on user's balance state
    const steps = [];
    const isSdai = tokenAddr.toLowerCase() === SDAI_ADDRESS.toLowerCase();
    let sdaiBal = 0n, wxdaiBal = 0n, nativeBal = 0n;

    if (isSdai) {
      sdaiBal = await getBalance(SDAI_ADDRESS);
      if (sdaiBal < bondAmount) {
        wxdaiBal = await getBalance(WXDAI_ADDRESS);
        nativeBal = await (provider || new ethers.JsonRpcProvider(GNOSIS_RPC)).getBalance(userAddr);

        // Apply 0.1% buffer for sDAI conversion rounding
        const sdaiDeficit = bondAmount - sdaiBal;
        const sdaiVault = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, signer);
        // convertToAssets gives us the underlying value; we need the reverse
        // Add a small buffer (0.1%) to handle rounding
        const wxdaiNeeded = sdaiDeficit + (sdaiDeficit / 1000n);

        if (wxdaiBal < wxdaiNeeded) {
          const wxdaiDeficit = wxdaiNeeded - wxdaiBal;
          const gasReserve = ethers.parseEther("0.01");
          if (nativeBal > gasReserve + wxdaiDeficit) {
            steps.push({ label: "Wrap xDAI to WXDAI", action: "wrapXdai", amount: wxdaiDeficit });
          } else if (nativeBal > gasReserve) {
            steps.push({ label: "Wrap xDAI to WXDAI", action: "wrapXdai", amount: nativeBal - gasReserve });
          } else {
            showMsg(msg, "Insufficient funds. Buy some USD first.", "error");
            btn.disabled = false; btn.textContent = "Create Bond"; return;
          }
        }
        steps.push({ label: "Approve WXDAI for vault", action: "approveWxdai" });
        steps.push({ label: "Deposit to USD Savings", action: "depositSdai" });
      }
    }

    // Check if token needs approval for the bond contract
    const currentAllowance = await tokenContract.allowance(userAddr, CONTRACT_ADDRESS);
    const currentBal = isSdai ? await getBalance(SDAI_ADDRESS) : await getBalance(tokenAddr);
    if (currentAllowance < bondAmount || (isSdai && sdaiBal < bondAmount)) {
      steps.push({ label: `Approve ${friendlyTokenName(tokenAddr, '')}`, action: "approveToken" });
    }

    steps.push({ label: "Create Bond", action: "createBond" });

    // Render stepper
    renderTxStepper(stepperEl, steps.map(s => s.label));
    let stepIdx = 0;

    // Execute steps
    for (const step of steps) {
      updateStepStatus(stepperEl, stepIdx, 'active');

      if (step.action === "wrapXdai") {
        await wrapXdaiToWxdai(step.amount);
      } else if (step.action === "approveWxdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await ensureApproval(WXDAI_ADDRESS, wxdaiBal2, SDAI_ADDRESS);
      } else if (step.action === "depositSdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await wrapWxdaiToSdai(wxdaiBal2);
      } else if (step.action === "approveToken") {
        // Re-read balance after potential wrapping
        const bal = await getBalance(tokenAddr);
        const approveAmt = bal > bondAmount ? bondAmount : bal;
        await ensureApproval(tokenAddr, approveAmt, CONTRACT_ADDRESS);
      } else if (step.action === "createBond") {
        const metadata = document.getElementById("bondMetadata").value.trim();
        const tx = await bondContract.createBond(tokenAddr, bondAmount, challengeAmount, judgeFee, judgeAddr, deadline, rulingBuffer, metadata);
        await tx.wait();

        // Parse bond ID from receipt
        const receipt = await (provider || new ethers.JsonRpcProvider(GNOSIS_RPC)).getTransactionReceipt(tx.hash);
        const iface = new ethers.Interface(BOND_ABI);
        let bondId = null;
        for (const log of receipt.logs) {
          try {
            const parsed = iface.parseLog({ topics: log.topics, data: log.data });
            if (parsed && parsed.name === "BondCreated") { bondId = parsed.args.bondId; break; }
          } catch (_) {}
        }

        updateStepStatus(stepperEl, stepIdx, 'done');

        if (bondId !== null) {
          msg.innerHTML = `<div class="success-card">
            <div class="sc-label">Bond created!</div>
            <div class="sc-id">Bond #${bondId}</div>
            <div class="sc-actions">
              <button class="success" onclick="viewBondById(${bondId})">View Bond</button>
              <button class="secondary" onclick="copyBondLink(${bondId})">Copy Link</button>
            </div>
          </div>`;
        } else {
          showMsg(msg, "Bond created! Check the transaction for the ID.", "success");
        }

        tokenCache = {};
        myBondsLoaded = false;
        browseBondsLoaded = false;
        refreshAllBalances();
        return; // Done
      }

      updateStepStatus(stepperEl, stepIdx, 'done');
      stepIdx++;
    }
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  } finally {
    btn.disabled = false;
    btn.textContent = "Create Bond";
  }
}

// ─── Tabs ─────────────────────────────────────────────────────────────
function switchTab(name) {
  document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.tab === name));
  ["create", "browse", "my", "view"].forEach(t => {
    const el = document.getElementById("tab-" + t);
    if (el) el.classList.toggle("hidden", t !== name);
  });
  if (name === "my" && userAddr) loadMyBonds();
  if (name === "browse") loadBrowseBonds();
}

// ─── Load Bond ────────────────────────────────────────────────────────
async function loadBond() {
  const idStr = document.getElementById("bondIdInput").value.trim();
  if (idStr === "") return;
  const bondId = parseInt(idStr);
  const msg = document.getElementById("viewMsg");

  try {
    const readProvider = provider || new ethers.JsonRpcProvider(GNOSIS_RPC);
    const readContract = new ethers.Contract(CONTRACT_ADDRESS, BOND_ABI, readProvider);

    const nextId = await readContract.nextBondId();
    if (BigInt(bondId) >= nextId) { showMsg(msg, `Bond #${bondId} does not exist yet (next ID: ${nextId})`, "error"); return; }

    const b = await readContract.bonds(bondId);
    const [poster, judge, token, bondAmount, challengeAmount, judgeFee, deadline, rulingDeadline, metadata, settled, currentChallenge] = b;

    const tokenContract = new ethers.Contract(token, ERC20_ABI, readProvider);
    let decimals = 18, symbol = "???";
    try { decimals = Number(await tokenContract.decimals()); } catch (_) {}
    try { symbol = await tokenContract.symbol(); } catch (_) {}

    const now = BigInt(Math.floor(Date.now() / 1000));
    const challengeCount = Number(await readContract.getChallengeCount(bondId));
    const currentIdx = Number(currentChallenge);

    // Determine status
    let status, statusClass;
    if (settled) {
      const filter1 = readContract.filters.RuledForChallenger(bondId);
      const filter2 = readContract.filters.BondWithdrawn(bondId);
      const filter3 = readContract.filters.BondTimedOut(bondId);
      const [evC, evW, evT] = await Promise.all([
        readContract.queryFilter(filter1, CONTRACT_DEPLOY_BLOCK).catch(() => []),
        readContract.queryFilter(filter2, CONTRACT_DEPLOY_BLOCK).catch(() => []),
        readContract.queryFilter(filter3, CONTRACT_DEPLOY_BLOCK).catch(() => []),
      ]);
      if (evC.length > 0) { status = "Challenger Won"; statusClass = "status-forfeited"; }
      else if (evW.length > 0) { status = "Withdrawn"; statusClass = "status-withdrawn"; }
      else if (evT.length > 0) { status = "Timed Out"; statusClass = "status-timedout"; }
      else { status = "Settled"; statusClass = "status-settled"; }
    } else if (now > rulingDeadline && currentIdx < challengeCount) {
      status = "Timeout (claimable)"; statusClass = "status-expired";
    } else if (now > deadline) {
      if (currentIdx < challengeCount) {
        status = "Ruling Period"; statusClass = "status-active";
      } else {
        status = "Expired (withdrawable)"; statusClass = "status-expired";
      }
    } else {
      status = "Active"; statusClass = "status-active";
    }

    currentViewBondId = bondId;
    currentViewBondData = { poster, judge, token, bondAmount, challengeAmount, judgeFee, deadline, rulingDeadline, metadata, settled, currentChallenge, decimals, symbol, challengeCount, currentIdx, status };

    document.getElementById("bondDisplay").classList.remove("hidden");
    document.getElementById("bId").textContent = bondId;
    document.getElementById("bStatus").innerHTML = `<span class="status-badge ${statusClass}">${status}</span>`;
    setAddrLink("bPoster", poster);
    setAddrLink("bJudge", judge);
    const tokenDisplayName = friendlyTokenName(token, symbol);
    setAddrLink("bToken", token, tokenDisplayName);
    const fmtBondAmt = parseFloat(ethers.formatUnits(bondAmount, decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
    const fmtChallengeAmt = parseFloat(ethers.formatUnits(challengeAmount, decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
    const fmtJudgeFee = parseFloat(ethers.formatUnits(judgeFee, decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
    document.getElementById("bBondAmount").textContent = `$${fmtBondAmt}`;
    document.getElementById("bChallengeAmount").textContent = `$${fmtChallengeAmt}`;
    document.getElementById("bJudgeFee").textContent = `$${fmtJudgeFee}`;
    document.getElementById("bDeadline").textContent = new Date(Number(deadline) * 1000).toLocaleString();
    document.getElementById("bRulingDeadline").textContent = new Date(Number(rulingDeadline) * 1000).toLocaleString();

    const metaRow = document.getElementById("bMetadataRow");
    const metaEl = document.getElementById("bMetadata");
    if (metadata) {
      metaEl.textContent = metadata;
      metaRow.style.display = "";
    } else {
      metaRow.style.display = "none";
    }

    const url = new URL(window.location);
    url.searchParams.set("bond", bondId);
    history.replaceState(null, "", url);

    // ─── Risk/Reward Card ────────────────────────────────────────
    const rrCard = document.getElementById("riskRewardCard");
    if (!settled && now <= deadline) {
      // Challenger can still challenge
      // Win: poster loses bond, challenger gets bond + challenge - judgeFee
      // Net profit = bondAmount - judgeFee (since challenge amount is returned + bond - fee)
      const netProfit = bondAmount - judgeFee;
      const netProfitFmt = parseFloat(ethers.formatUnits(netProfit, decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const riskFmt = fmtChallengeAmt;

      document.getElementById("rrWinAmount").textContent = `+$${netProfitFmt}`;
      document.getElementById("rrRiskAmount").textContent = `$${riskFmt}`;
      document.getElementById("rrNote").textContent = `If you lose, you forfeit your $${riskFmt} deposit. The judge decides the outcome.`;
      document.getElementById("challengeStepper").innerHTML = "";
      document.getElementById("challengeMsg").innerHTML = "";
      rrCard.classList.remove("hidden");
    } else {
      rrCard.classList.add("hidden");
    }

    // ─── Challenge Queue ────────────────────────────────────────
    const queueSection = document.getElementById("challengeQueueSection");
    const challengeList = document.getElementById("challengeList");
    challengeList.innerHTML = "";

    if (challengeCount > 0) {
      queueSection.classList.remove("hidden");
      const statusLabels = ["Pending", "Won", "Lost", "Refunded"];
      const statusClasses = ["status-pending", "status-won", "status-lost", "status-refunded"];

      for (let i = 0; i < challengeCount; i++) {
        const [cAddr, cStatus] = await readContract.getChallenge(bondId, i);
        const isCurrent = (i === currentIdx && !settled);
        const item = document.createElement("div");
        item.className = "challenge-item" + (isCurrent ? " current" : "");
        item.innerHTML = `
          <div>
            <span class="ci-idx">#${i}</span>
            <span class="ci-addr">${short(cAddr)}</span>
            ${isCurrent ? ' <span style="color:var(--accent);font-size:11px;">(current)</span>' : ''}
          </div>
          <span class="status-badge ${statusClasses[cStatus]}">${statusLabels[cStatus]}</span>`;
        challengeList.appendChild(item);
      }
    } else {
      queueSection.classList.add("hidden");
    }

    // ─── Action Buttons ─────────────────────────────────────────
    const actionsDiv = document.getElementById("bondActions");
    const btnsDiv = document.getElementById("actionBtns");
    btnsDiv.innerHTML = "";

    if (!settled && signer) {
      const ua = userAddr.toLowerCase();
      const hasPendingChallenge = currentIdx < challengeCount;

      // Judge actions on current challenge
      if (ua === judge.toLowerCase() && hasPendingChallenge && now <= rulingDeadline) {
        const ruleForCBtn = document.createElement("button");
        ruleForCBtn.className = "danger";
        ruleForCBtn.textContent = "Rule for Challenger";
        ruleForCBtn.onclick = () => doRuleForChallenger(bondId);
        btnsDiv.appendChild(ruleForCBtn);

        const ruleForPBtn = document.createElement("button");
        ruleForPBtn.className = "success";
        ruleForPBtn.textContent = "Rule for Poster";
        ruleForPBtn.onclick = () => doRuleForPoster(bondId);
        btnsDiv.appendChild(ruleForPBtn);
      }

      // Poster withdraw
      if (ua === poster.toLowerCase() && !hasPendingChallenge) {
        const wdBtn = document.createElement("button");
        wdBtn.className = "success";
        wdBtn.textContent = "Withdraw Bond";
        wdBtn.onclick = () => doWithdrawBond(bondId);
        btnsDiv.appendChild(wdBtn);
      }

      // Timeout claim
      if (now > rulingDeadline && hasPendingChallenge) {
        const toBtn = document.createElement("button");
        toBtn.className = "secondary";
        toBtn.textContent = "Claim Timeout (Refund All)";
        toBtn.onclick = () => doClaimTimeout(bondId);
        btnsDiv.appendChild(toBtn);
      }

      actionsDiv.classList.toggle("hidden", btnsDiv.children.length === 0);
    } else {
      actionsDiv.classList.add("hidden");
    }
    msg.innerHTML = "";
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  }
}

// ─── Smart Challenge (with stepper) ──────────────────────────────────
async function smartChallengeBond() {
  if (!currentViewBondId && currentViewBondId !== 0) return;
  const bondId = currentViewBondId;
  const btn = document.getElementById("challengeBtn");
  const msg = document.getElementById("challengeMsg");
  const stepperEl = document.getElementById("challengeStepper");

  if (!signer) {
    showMsg(msg, "Sign in first to challenge this bond.", "error");
    return;
  }

  try {
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Processing...';

    const readContract = new ethers.Contract(CONTRACT_ADDRESS, BOND_ABI, signer);
    const b = await readContract.bonds(bondId);
    const tokenAddr = b[2];
    const challengeAmount = b[4];

    const isSdai = tokenAddr.toLowerCase() === SDAI_ADDRESS.toLowerCase();
    const steps = [];

    // Check if user has enough of the challenge token
    const tokenBal = await getBalance(tokenAddr);

    if (tokenBal < challengeAmount && isSdai) {
      // Try wrapping
      const wxdaiBal = await getBalance(WXDAI_ADDRESS);
      const nativeBal = await (provider || new ethers.JsonRpcProvider(GNOSIS_RPC)).getBalance(userAddr);
      const sdaiDeficit = challengeAmount - tokenBal;
      const wxdaiNeeded = sdaiDeficit + (sdaiDeficit / 1000n);

      if (wxdaiBal < wxdaiNeeded) {
        const wxdaiDeficit = wxdaiNeeded - wxdaiBal;
        const gasReserve = ethers.parseEther("0.01");
        if (nativeBal > gasReserve + wxdaiDeficit) {
          steps.push({ label: "Wrap xDAI to WXDAI", action: "wrapXdai", amount: wxdaiDeficit });
        } else {
          showMsg(msg, "Insufficient funds to challenge. Get more USD first.", "error");
          showFundingOptions(msg);
          btn.disabled = false; btn.textContent = "Challenge This Bond"; return;
        }
      }
      steps.push({ label: "Approve WXDAI for vault", action: "approveWxdai" });
      steps.push({ label: "Deposit to USD Savings", action: "depositSdai", amount: wxdaiNeeded });
    } else if (tokenBal < challengeAmount) {
      showMsg(msg, "Insufficient token balance to challenge.", "error");
      btn.disabled = false; btn.textContent = "Challenge This Bond"; return;
    }

    // Approve + Challenge
    const tokenContract = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
    const currentAllowance = await tokenContract.allowance(userAddr, CONTRACT_ADDRESS);
    if (currentAllowance < challengeAmount) {
      steps.push({ label: "Approve currency", action: "approveToken" });
    }
    steps.push({ label: "Submit Challenge", action: "challenge" });

    renderTxStepper(stepperEl, steps.map(s => s.label));
    let stepIdx = 0;

    for (const step of steps) {
      updateStepStatus(stepperEl, stepIdx, 'active');

      if (step.action === "wrapXdai") {
        await wrapXdaiToWxdai(step.amount);
      } else if (step.action === "approveWxdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await ensureApproval(WXDAI_ADDRESS, wxdaiBal2, SDAI_ADDRESS);
      } else if (step.action === "depositSdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await wrapWxdaiToSdai(wxdaiBal2);
      } else if (step.action === "approveToken") {
        await ensureApproval(tokenAddr, challengeAmount, CONTRACT_ADDRESS);
      } else if (step.action === "challenge") {
        const tx = await bondContract.challenge(bondId);
        await tx.wait();
      }

      updateStepStatus(stepperEl, stepIdx, 'done');
      stepIdx++;
    }

    showMsg(msg, "Challenge submitted!", "success");
    loadBond();
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  } finally {
    btn.disabled = false;
    btn.textContent = "Challenge This Bond";
  }
}

function showFundingOptions(msgEl) {
  const fundingHtml = `<div style="margin-top:8px;">
    <button onclick="openTransak()" style="font-size:12px;padding:6px 12px;">Buy with Credit Card</button>
    <button class="copy-addr-btn" onclick="copyAddress()" style="margin-left:6px;">Copy Wallet Address</button>
  </div>`;
  msgEl.innerHTML += fundingHtml;
}

// ─── Bond actions ─────────────────────────────────────────────────────
async function doRuleForChallenger(bondId) {
  const msg = document.getElementById("viewMsg");
  try {
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.ruleForChallenger(bondId);
    await tx.wait();
    showMsg(msg, "Ruled for challenger. Bond settled.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

async function doRuleForPoster(bondId) {
  const msg = document.getElementById("viewMsg");
  try {
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.ruleForPoster(bondId);
    await tx.wait();
    showMsg(msg, "Ruled for poster. Queue advanced.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

async function doWithdrawBond(bondId) {
  const msg = document.getElementById("viewMsg");
  try {
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.withdrawBond(bondId);
    await tx.wait();
    showMsg(msg, "Bond withdrawn.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

async function doClaimTimeout(bondId) {
  const msg = document.getElementById("viewMsg");
  try {
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.claimTimeout(bondId);
    await tx.wait();
    showMsg(msg, "Timeout claimed. All refunded.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

// ─── Browse Active Bonds ──────────────────────────────────────────────
async function loadBrowseBonds() {
  if (browseBondsLoaded) return;

  const listEl = document.getElementById("browseBondsList");
  const loadingEl = document.getElementById("browseLoading");
  const emptyEl = document.getElementById("browseEmpty");

  loadingEl.classList.remove("hidden");
  listEl.innerHTML = "";
  emptyEl.classList.add("hidden");

  try {
    const readProvider = provider || new ethers.JsonRpcProvider(GNOSIS_RPC);
    const readContract = new ethers.Contract(CONTRACT_ADDRESS, BOND_ABI, readProvider);

    // Get all BondCreated events
    const filter = readContract.filters.BondCreated();
    const events = await readContract.queryFilter(filter, CONTRACT_DEPLOY_BLOCK).catch(() => []);

    const now = BigInt(Math.floor(Date.now() / 1000));
    const activeBonds = [];

    // Check each bond
    for (const ev of events) {
      const bondId = Number(ev.args.bondId);
      try {
        const b = await readContract.bonds(bondId);
        const [, , token, bondAmount, challengeAmount, , deadline, , metadata, settled] = b;
        if (!settled && deadline > now) {
          let symbol = "???", decimals = 18;
          try {
            const tc = new ethers.Contract(token, ERC20_ABI, readProvider);
            [symbol, decimals] = await Promise.all([tc.symbol(), tc.decimals().then(Number)]);
          } catch (_) {}

          activeBonds.push({ bondId, token, bondAmount, challengeAmount, deadline, metadata, symbol, decimals });
        }
      } catch (_) {}
    }

    loadingEl.classList.add("hidden");

    if (activeBonds.length === 0) {
      emptyEl.classList.remove("hidden");
      browseBondsLoaded = true;
      return;
    }

    // Sort by deadline (soonest first)
    activeBonds.sort((a, b) => Number(a.deadline - b.deadline));

    for (const bond of activeBonds) {
      const displayName = friendlyTokenName(bond.token, bond.symbol);
      const bondAmt = parseFloat(ethers.formatUnits(bond.bondAmount, bond.decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const challengeAmt = parseFloat(ethers.formatUnits(bond.challengeAmount, bond.decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const deadlineDate = new Date(Number(bond.deadline) * 1000);
      const countdown = formatCountdown(Number(bond.deadline));
      const desc = bond.metadata || "No description";

      const card = document.createElement("div");
      card.className = "bond-browse-item";
      card.onclick = () => viewBondById(bond.bondId);
      card.innerHTML = `
        <div class="bb-desc">${escapeHtml(desc)}</div>
        <div class="bond-browse-stats">
          <span>Bond: <span class="stat-val">$${bondAmt}</span></span>
          <span>Challenge: <span class="stat-val">$${challengeAmt}</span></span>
          <span>Deadline: <span class="countdown">${countdown}</span></span>
        </div>`;
      listEl.appendChild(card);
    }

    browseBondsLoaded = true;
  } catch (err) {
    loadingEl.classList.add("hidden");
    listEl.innerHTML = `<div class="msg msg-error">Error loading bonds: ${err.message}</div>`;
  }
}

function formatCountdown(unixTimestamp) {
  const now = Math.floor(Date.now() / 1000);
  const diff = unixTimestamp - now;
  if (diff <= 0) return "Expired";
  const days = Math.floor(diff / 86400);
  const hours = Math.floor((diff % 86400) / 3600);
  if (days > 30) return `${Math.floor(days / 30)} months`;
  if (days > 0) return `${days}d ${hours}h`;
  const mins = Math.floor((diff % 3600) / 60);
  return `${hours}h ${mins}m`;
}

// ─── Helpers ──────────────────────────────────────────────────────────
function setDeadline(days) {
  const d = new Date(Date.now() + days * 86400000);
  document.getElementById("deadline").value = d.toISOString().slice(0, 10);
  document.querySelectorAll(".preset:not(.ruling-preset)").forEach(b => b.classList.toggle("active", b.dataset.days == days));
}

function setRulingBuffer(days) {
  rulingBufferDays = days;
  document.querySelectorAll(".ruling-preset").forEach(b => b.classList.toggle("active", b.dataset.buffer == days));
}

function short(addr) { return addr.slice(0, 6) + "..." + addr.slice(-4); }

function setAddrLink(elId, addr, label) {
  const el = document.getElementById(elId);
  el.href = GNOSISSCAN + addr;
  el.textContent = label ? `${label} (${short(addr)})` : short(addr);
}

function showMsg(el, html, type) {
  el.innerHTML = `<div class="msg msg-${type}">${html}</div>`;
}

function viewBondById(id) {
  document.getElementById("bondIdInput").value = id;
  switchTab("view");
  loadBond();
}

function copyBondLink(id) {
  const url = `${window.location.origin}${window.location.pathname}?bond=${id}`;
  navigator.clipboard.writeText(url).then(() => {
    const btn = event.target;
    btn.textContent = "Copied!";
    setTimeout(() => { btn.textContent = "Copy Link"; }, 1500);
  }).catch(() => { prompt("Copy this link:", url); });
}

function escapeHtml(str) {
  const d = document.createElement("div");
  d.textContent = str;
  return d.innerHTML;
}

async function refreshAllBalances() {
  if (!userAddr || !signer) return;
  const tokens = getAllTokens();
  const promises = tokens.map(async (t) => {
    try {
      const token = new ethers.Contract(t.address, ERC20_ABI, signer);
      const [balance, allowance, decimals, symbol] = await Promise.all([
        token.balanceOf(userAddr),
        token.allowance(userAddr, CONTRACT_ADDRESS),
        token.decimals(),
        token.symbol(),
      ]);
      tokenCache[t.address.toLowerCase()] = { symbol, decimals: Number(decimals), balance, allowance };
    } catch (_) {}
  });
  await Promise.all(promises);
  buildTokenSelect();
  const sel = document.getElementById("tokenSelect");
  if (!sel.value) sel.value = SDAI_ADDRESS;
  updateBalanceDisplay(getSelectedToken());
}

// ─── My Bonds ─────────────────────────────────────────────────────────
async function loadMyBonds() {
  if (!userAddr) return;
  const listEl = document.getElementById("myBondsList");
  const loadingEl = document.getElementById("myBondsLoading");
  const emptyEl = document.getElementById("myBondsEmpty");
  const contentEl = document.getElementById("myBondsContent");
  const connectEl = document.getElementById("myBondsConnect");

  connectEl.classList.add("hidden");
  contentEl.classList.remove("hidden");

  if (myBondsLoaded) return;

  loadingEl.classList.remove("hidden");
  listEl.innerHTML = "";
  emptyEl.classList.add("hidden");

  try {
    const readProvider = provider || new ethers.JsonRpcProvider(GNOSIS_RPC);
    const readContract = new ethers.Contract(CONTRACT_ADDRESS, BOND_ABI, readProvider);

    const posterFilter = readContract.filters.BondCreated(null, userAddr);
    const judgeFilter = readContract.filters.BondCreated(null, null, userAddr);
    const challengerFilter = readContract.filters.Challenged(null, null, userAddr);

    const [posterEvents, judgeEvents, challengerEvents] = await Promise.all([
      readContract.queryFilter(posterFilter, CONTRACT_DEPLOY_BLOCK).catch(() => []),
      readContract.queryFilter(judgeFilter, CONTRACT_DEPLOY_BLOCK).catch(() => []),
      readContract.queryFilter(challengerFilter, CONTRACT_DEPLOY_BLOCK).catch(() => []),
    ]);

    const seen = new Set();
    const allBondIds = [];
    for (const ev of [...posterEvents, ...judgeEvents]) {
      const id = Number(ev.args.bondId);
      if (!seen.has(id)) { seen.add(id); allBondIds.push(id); }
    }
    for (const ev of challengerEvents) {
      const id = Number(ev.args.bondId);
      if (!seen.has(id)) { seen.add(id); allBondIds.push(id); }
    }

    allBondIds.sort((a, b) => b - a);
    loadingEl.classList.add("hidden");

    if (allBondIds.length === 0) {
      emptyEl.classList.remove("hidden");
      myBondsLoaded = true;
      return;
    }

    for (const id of allBondIds) {
      const b = await readContract.bonds(id);
      const [poster, judge, token, bondAmount, challengeAmount, judgeFee, deadline, rulingDeadline, metadata, settled, currentChallenge] = b;

      let symbol = "???", decimals = 18;
      const tokenContract = new ethers.Contract(token, ERC20_ABI, readProvider);
      try { symbol = await tokenContract.symbol(); } catch (_) {}
      try { decimals = Number(await tokenContract.decimals()); } catch (_) {}

      const now = BigInt(Math.floor(Date.now() / 1000));
      let status, statusClass;
      if (settled) { status = "Settled"; statusClass = "status-settled"; }
      else if (now > rulingDeadline) { status = "Timeout"; statusClass = "status-expired"; }
      else if (now > deadline) { status = "Ruling"; statusClass = "status-active"; }
      else { status = "Active"; statusClass = "status-active"; }

      const ua = userAddr.toLowerCase();
      const isPoster = ua === poster.toLowerCase();
      const isJudge = ua === judge.toLowerCase();
      const challengeCount = Number(await readContract.getChallengeCount(id));
      let isChallenger = false;
      for (let i = 0; i < challengeCount; i++) {
        const [cAddr] = await readContract.getChallenge(id, i);
        if (cAddr.toLowerCase() === ua) { isChallenger = true; break; }
      }

      let roles = [];
      if (isPoster) roles.push("Poster");
      if (isJudge) roles.push("Judge");
      if (isChallenger) roles.push("Challenger");
      const role = roles.join(" & ");

      const desc = metadata || "No description";
      const amtStr = parseFloat(ethers.formatUnits(bondAmount, decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const displayName = friendlyTokenName(token, symbol);

      const item = document.createElement("div");
      item.className = "bond-item";
      item.onclick = () => viewBondById(id);
      item.innerHTML = `
        <div class="bi-left">
          <div class="bi-id">Bond #${id} <span class="status-badge ${statusClass}" style="font-size:10px;vertical-align:middle;">${status}</span></div>
          <div class="bi-meta">${escapeHtml(desc)}</div>
        </div>
        <div class="bi-right">
          <div class="bi-amount">$${amtStr}</div>
          <div class="bi-role">${role}</div>
        </div>`;
      listEl.appendChild(item);
    }

    myBondsLoaded = true;
  } catch (err) {
    loadingEl.classList.add("hidden");
    listEl.innerHTML = `<div class="msg msg-error">Error loading bonds: ${err.message}</div>`;
  }
}

// ─── Form persistence ─────────────────────────────────────────────────
const FORM_FIELDS = ["tokenSelect", "bondAmount", "challengeAmount", "judgeFee", "judgeAddr", "bondMetadata", "deadline", "bondIdInput"];

function saveForm() {
  const data = {};
  for (const id of FORM_FIELDS) {
    const el = document.getElementById(id);
    if (el) data[id] = el.value;
  }
  data._rulingBuffer = rulingBufferDays;
  data._mode = currentMode;
  const activeTab = document.querySelector(".tab.active");
  if (activeTab) data._tab = activeTab.dataset.tab;
  sessionStorage.setItem("bondForm", JSON.stringify(data));
}

function restoreForm() {
  try {
    const raw = sessionStorage.getItem("bondForm");
    if (!raw) return;
    const data = JSON.parse(raw);
    for (const id of FORM_FIELDS) {
      const el = document.getElementById(id);
      if (el && data[id]) el.value = data[id];
    }
    if (data._rulingBuffer) setRulingBuffer(data._rulingBuffer);
    if (data._mode) setMode(data._mode);
    if (data._tab) switchTab(data._tab);
  } catch (_) {}
}

// ─── Init ─────────────────────────────────────────────────────────────
window.addEventListener("DOMContentLoaded", async () => {
  buildTokenSelect();
  // Default to sDAI in simple mode
  document.getElementById("tokenSelect").value = SDAI_ADDRESS;
  restoreForm();

  const params = new URLSearchParams(window.location.search);
  const bondParam = params.get("bond");
  if (bondParam !== null) {
    // Deep link: show main app and go to view tab
    document.getElementById("connectScreen").classList.add("hidden");
    document.getElementById("mainApp").classList.remove("hidden");
    document.getElementById("connectBtn").classList.remove("hidden");
    switchTab("view");
    document.getElementById("bondIdInput").value = bondParam;
    setTimeout(() => loadBond(), 500);
  }

  // Try auto-reconnect
  let autoConnected = false;

  // Check Web3Auth reconnection
  if (WEB3AUTH_CLIENT_ID !== "YOUR_WEB3AUTH_CLIENT_ID") {
    try {
      const w3a = await initWeb3Auth();
      if (w3a && w3a.connected) {
        web3authProvider = w3a.provider;
        connectionType = 'web3auth';
        provider = new ethers.BrowserProvider(w3a.provider);
        signer = await provider.getSigner();
        userAddr = await signer.getAddress();
        bondContract = new ethers.Contract(CONTRACT_ADDRESS, BOND_ABI, signer);
        onWalletConnected();
        autoConnected = true;
      }
    } catch (_) {}
  }

  // Check injected wallet reconnection
  if (!autoConnected && window.ethereum) {
    try {
      const accounts = await window.ethereum.request({ method: "eth_accounts" });
      if (accounts && accounts.length > 0) {
        await connectInjectedWallet();
        autoConnected = true;
      }
    } catch (_) {}
  }

  // If no auto-connect and no deep link, show connect screen
  if (!autoConnected && bondParam === null) {
    showConnectScreen();
  }

  // Save form on unload
  window.addEventListener("beforeunload", saveForm);
});
</script>
</body>
</html>
