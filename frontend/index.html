<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SimpleBond v0.4 — Futarchy</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@web3auth/modal@7/dist/modal.umd.min.js"></script>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --border: #2a2a3a;
    --text: #e0e0e8;
    --muted: #8888a0;
    --accent: #6c5ce7;
    --accent-hover: #7d6ff0;
    --green: #00b894;
    --red: #e74c3c;
    --orange: #f39c12;
    --blue: #3498db;
    --surface-hover: #1a1a24;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    line-height: 1.5;
  }
  .container { max-width: 640px; margin: 0 auto; padding: 24px 16px; }
  header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 16px 0; border-bottom: 1px solid var(--border); margin-bottom: 32px;
  }
  header h1 { font-size: 20px; font-weight: 600; }
  header h1 span { color: var(--muted); font-weight: 400; }
  .wallet-info { text-align: right; font-size: 13px; }
  .wallet-info .address { color: var(--accent); font-family: monospace; }
  .wallet-info .chain { color: var(--muted); font-size: 11px; }
  .wallet-info .disconnect-link {
    color: var(--muted); font-size: 11px; cursor: pointer;
    text-decoration: underline; margin-top: 2px;
  }
  .wallet-info .disconnect-link:hover { color: var(--red); }
  button {
    background: var(--accent); color: #fff; border: none; padding: 10px 20px;
    border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500;
    transition: background 0.15s;
  }
  button:hover { background: var(--accent-hover); }
  button:disabled { opacity: 0.4; cursor: not-allowed; }
  button.secondary { background: var(--surface); border: 1px solid var(--border); color: var(--text); }
  button.secondary:hover { border-color: var(--muted); }
  button.danger { background: var(--red); }
  button.success { background: var(--green); }
  .card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; padding: 24px; margin-bottom: 24px;
  }
  .card h2 { font-size: 16px; margin-bottom: 16px; font-weight: 600; }
  .form-group { margin-bottom: 14px; }
  .form-group label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 4px; }
  input, select, textarea {
    width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text); font-size: 14px; outline: none;
    font-family: inherit;
  }
  input:focus, select:focus, textarea:focus { border-color: var(--accent); }
  input::placeholder, textarea::placeholder { color: var(--muted); }
  textarea { resize: vertical; min-height: 60px; }
  .btn-row { display: flex; gap: 8px; margin-top: 16px; }
  .btn-row button { flex: 1; }
  .status-badge {
    display: inline-block; padding: 3px 10px; border-radius: 12px;
    font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;
  }
  .status-active { background: rgba(0,184,148,0.15); color: var(--green); }
  .status-forfeited { background: rgba(231,76,60,0.15); color: var(--red); }
  .status-settled { background: rgba(108,92,231,0.15); color: var(--accent); }
  .status-withdrawn { background: rgba(136,136,160,0.15); color: var(--muted); }
  .status-expired { background: rgba(243,156,18,0.15); color: var(--orange); }
  .status-timedout { background: rgba(243,156,18,0.15); color: var(--orange); }
  .status-pending { background: rgba(52,152,219,0.15); color: var(--blue); }
  .status-won { background: rgba(0,184,148,0.15); color: var(--green); }
  .status-lost { background: rgba(231,76,60,0.15); color: var(--red); }
  .status-refunded { background: rgba(136,136,160,0.15); color: var(--muted); }
  .bond-detail { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  .bond-field .label { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
  .bond-field .value { font-size: 14px; word-break: break-all; }
  .bond-field .value a { color: var(--accent); text-decoration: none; }
  .bond-field .value a:hover { text-decoration: underline; }
  .bond-field.full { grid-column: 1 / -1; }
  .actions { margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border); }
  .msg { padding: 10px 14px; border-radius: 8px; margin-top: 12px; font-size: 13px; }
  .msg-error { background: rgba(231,76,60,0.12); color: var(--red); }
  .msg-success { background: rgba(0,184,148,0.12); color: var(--green); }
  .msg-info { background: rgba(108,92,231,0.12); color: var(--accent); }
  .tabs { display: flex; gap: 0; margin-bottom: 24px; }
  .tab {
    flex: 1; padding: 10px; text-align: center; cursor: pointer;
    border-bottom: 2px solid transparent; color: var(--muted); font-size: 14px;
    font-weight: 500; transition: all 0.15s;
  }
  .tab.active { border-bottom-color: var(--accent); color: var(--text); }
  .tab:hover { color: var(--text); }
  .hidden { display: none !important; }
  .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 0.6s linear infinite; margin-right: 6px; vertical-align: middle; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .connect-prompt { text-align: center; padding: 40px 0; color: var(--muted); }
  .preset-row { display: flex; gap: 6px; margin-bottom: 8px; }
  .preset { background: var(--bg); border: 1px solid var(--border); color: var(--muted); padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; flex: 1; }
  .preset:hover { border-color: var(--accent); color: var(--text); }
  .preset.active { border-color: var(--accent); color: var(--accent); background: rgba(108,92,231,0.1); }
  .token-balance { font-size: 12px; color: var(--muted); margin-top: 4px; }
  .token-balance .bal { color: var(--text); font-family: monospace; }
  .token-row { display: flex; gap: 8px; align-items: center; }
  .token-row select { flex: 1; }
  .token-row .add-token-btn { padding: 10px 14px; font-size: 13px; white-space: nowrap; flex-shrink: 0; }
  .hint { font-size: 12px; color: var(--muted); margin-top: 4px; }
  .approval-status { font-size: 12px; margin-top: 4px; }
  .approval-ok { color: var(--green); }
  .approval-need { color: var(--orange); }
  .bond-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 14px; border: 1px solid var(--border); border-radius: 8px;
    margin-bottom: 8px; cursor: pointer; transition: border-color 0.15s;
  }
  .bond-item:hover { border-color: var(--accent); }
  .bond-item .bi-left { }
  .bond-item .bi-id { font-weight: 600; font-size: 15px; }
  .bond-item .bi-meta { font-size: 12px; color: var(--muted); margin-top: 2px; max-width: 360px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .bond-item .bi-right { text-align: right; }
  .bond-item .bi-amount { font-size: 14px; font-family: monospace; }
  .bond-item .bi-role { font-size: 11px; color: var(--muted); margin-top: 2px; }
  .success-card {
    background: rgba(0,184,148,0.08); border: 1px solid var(--green);
    border-radius: 10px; padding: 20px; text-align: center; margin-top: 16px;
  }
  .success-card .sc-id { font-size: 28px; font-weight: 700; color: var(--green); }
  .success-card .sc-label { font-size: 13px; color: var(--muted); margin-bottom: 4px; }
  .success-card .sc-actions { margin-top: 14px; display: flex; gap: 8px; justify-content: center; }
  .success-card .sc-actions button { flex: none; }
  .challenge-queue { margin-top: 16px; }
  .challenge-queue h3 { font-size: 14px; font-weight: 600; margin-bottom: 8px; }
  .challenge-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px;
    margin-bottom: 6px; font-size: 13px;
  }
  .challenge-item.current { border-color: var(--accent); background: rgba(108,92,231,0.06); }
  .challenge-item .ci-idx { color: var(--muted); margin-right: 8px; font-family: monospace; }
  .challenge-item .ci-addr { font-family: monospace; }
  .amounts-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
  footer { text-align: center; padding: 24px 0; color: var(--muted); font-size: 12px; border-top: 1px solid var(--border); margin-top: 32px; }
  footer a { color: var(--accent); text-decoration: none; }

  /* ─── Connection Screen ─── */
  .connect-screen {
    text-align: center; padding: 60px 20px;
  }
  .connect-screen h2 {
    font-size: 28px; font-weight: 700; margin-bottom: 8px;
    background: linear-gradient(135deg, var(--accent), var(--blue));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .connect-screen .subtitle {
    color: var(--muted); font-size: 15px; margin-bottom: 32px; max-width: 380px; margin-inline: auto;
  }
  .connect-options { display: flex; flex-direction: column; gap: 12px; max-width: 340px; margin: 0 auto; }
  .connect-option {
    padding: 14px 20px; border-radius: 10px; cursor: pointer;
    font-size: 15px; font-weight: 500; text-align: center; transition: all 0.15s;
  }
  .connect-option-primary {
    background: var(--accent); color: #fff; border: none;
  }
  .connect-option-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
  .connect-option-secondary {
    background: var(--surface); color: var(--text); border: 1px solid var(--border);
  }
  .connect-option-secondary:hover { border-color: var(--muted); }
  .connect-screen .browse-link {
    margin-top: 20px; font-size: 13px; color: var(--muted); cursor: pointer;
    text-decoration: underline;
  }
  .connect-screen .browse-link:hover { color: var(--text); }


  /* ─── Funding Banner ─── */
  .funding-banner {
    background: rgba(108,92,231,0.06); border: 1px solid rgba(108,92,231,0.15);
    border-radius: 8px; padding: 10px 14px; margin-bottom: 16px; font-size: 13px; color: var(--muted);
  }

  /* ─── Transaction Stepper ─── */
  .tx-stepper {
    display: flex; flex-direction: column; gap: 0; margin: 16px 0;
    background: var(--bg); border-radius: 10px; padding: 16px; border: 1px solid var(--border);
  }
  .tx-step {
    display: flex; align-items: center; gap: 12px; padding: 10px 0;
    position: relative; color: var(--muted); font-size: 13px;
  }
  .tx-step:not(:last-child)::after {
    content: ''; position: absolute; left: 13px; top: 38px;
    width: 2px; height: calc(100% - 18px); background: var(--border);
  }
  .tx-step .step-num {
    width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
    background: var(--surface); border: 2px solid var(--border); font-size: 12px; font-weight: 600;
    flex-shrink: 0; z-index: 1;
  }
  .tx-step.tx-step-active { color: var(--text); }
  .tx-step.tx-step-active .step-num {
    border-color: var(--accent); color: var(--accent);
  }
  .tx-step.tx-step-active .step-num .spinner {
    width: 14px; height: 14px; margin: 0; border-width: 2px;
    border-color: rgba(108,92,231,0.3); border-top-color: var(--accent);
  }
  .tx-step.tx-step-done { color: var(--green); }
  .tx-step.tx-step-done .step-num {
    background: var(--green); border-color: var(--green); color: #fff;
  }
  .tx-step.tx-step-done::after { background: var(--green); }
  .tx-step .step-label { flex: 1; }

  /* ─── Browse Bonds ─── */
  .bond-browse-item {
    background: var(--bg); border: 1px solid var(--border); border-radius: 10px;
    padding: 16px; margin-bottom: 10px; cursor: pointer; transition: all 0.15s;
  }
  .bond-browse-item:hover { border-color: var(--accent); transform: translateY(-1px); }
  .bond-browse-item .bb-desc {
    font-size: 14px; font-weight: 500; margin-bottom: 8px;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
  }
  .bond-browse-stats {
    display: flex; gap: 16px; flex-wrap: wrap; font-size: 12px; color: var(--muted);
  }
  .bond-browse-stats .stat-val { color: var(--text); font-weight: 500; }
  .countdown { color: var(--orange); font-weight: 500; }

  /* ─── Risk/Reward Card ─── */
  .risk-reward-card {
    background: var(--bg); border: 1px solid var(--border); border-radius: 10px;
    padding: 20px; margin-top: 16px;
  }
  .risk-reward-card h3 { font-size: 15px; font-weight: 600; margin-bottom: 12px; }
  .risk-reward-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
  .reward-item {
    background: rgba(0,184,148,0.08); border: 1px solid rgba(0,184,148,0.2);
    border-radius: 8px; padding: 12px; text-align: center;
  }
  .reward-item .rr-label { font-size: 11px; color: var(--green); text-transform: uppercase; letter-spacing: 0.5px; }
  .reward-item .rr-value { font-size: 20px; font-weight: 700; color: var(--green); margin-top: 4px; }
  .risk-item {
    background: rgba(231,76,60,0.08); border: 1px solid rgba(231,76,60,0.2);
    border-radius: 8px; padding: 12px; text-align: center;
  }
  .risk-item .rr-label { font-size: 11px; color: var(--red); text-transform: uppercase; letter-spacing: 0.5px; }
  .risk-item .rr-value { font-size: 20px; font-weight: 700; color: var(--red); margin-top: 4px; }
  .risk-reward-card .rr-note { font-size: 12px; color: var(--muted); margin-bottom: 14px; }

  /* ─── Funding Guide Overlay ─── */
  .funding-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.75); z-index: 1000;
    display: flex; align-items: center; justify-content: center;
  }
  .funding-guide {
    background: var(--surface); border: 1px solid var(--border); border-radius: 16px;
    width: 480px; max-width: 95vw; max-height: 90vh; overflow-y: auto;
    padding: 28px; position: relative;
  }
  .funding-guide h3 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
  .funding-guide-close {
    position: absolute; top: 12px; right: 16px;
    background: none !important; color: var(--muted); border: none; font-size: 22px;
    cursor: pointer; padding: 4px 8px; width: auto; line-height: 1;
  }
  .funding-guide-close:hover { color: var(--text); background: none !important; }
  .funding-option {
    background: var(--bg); border: 1px solid var(--border); border-radius: 10px;
    padding: 16px; margin-bottom: 12px;
  }
  .funding-option h4 { font-size: 14px; font-weight: 600; margin-bottom: 4px; }
  .funding-option p { font-size: 13px; color: var(--muted); margin: 0; }
  .funding-option .fo-fee { font-size: 12px; margin-top: 6px; }
  .funding-option .fo-fee-free { color: var(--green); }
  .funding-option .fo-fee-low { color: var(--orange); }
  .funding-option .fo-steps { font-size: 12px; color: var(--muted); margin-top: 8px; padding-left: 16px; }
  .funding-option .fo-steps li { margin-bottom: 4px; }

  /* ─── Concession Display ─── */
  .concession-card {
    background: rgba(231,76,60,0.06); border: 1px solid rgba(231,76,60,0.25);
    border-radius: 10px; padding: 16px; margin-top: 16px;
  }
  .concession-card h3 { font-size: 14px; font-weight: 600; color: var(--red); margin-bottom: 8px; }
  .concession-card .concession-text { font-size: 13px; color: var(--text); white-space: pre-wrap; }
  .status-conceded { background: rgba(231,76,60,0.15); color: var(--red); }

  /* ─── Belief Thresholds ─── */
  .belief-card {
    background: var(--bg); border: 1px solid var(--border); border-radius: 10px;
    padding: 16px; margin-top: 12px;
  }
  .belief-card h3 { font-size: 13px; font-weight: 600; margin-bottom: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
  .belief-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .belief-item { padding: 10px; border-radius: 8px; text-align: center; }
  .belief-challenger { background: rgba(52,152,219,0.08); border: 1px solid rgba(52,152,219,0.2); }
  .belief-poster { background: rgba(243,156,18,0.08); border: 1px solid rgba(243,156,18,0.2); }
  .belief-item .belief-label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
  .belief-challenger .belief-label { color: var(--blue); }
  .belief-poster .belief-label { color: var(--orange); }
  .belief-item .belief-value { font-size: 22px; font-weight: 700; margin-top: 2px; }
  .belief-challenger .belief-value { color: var(--blue); }
  .belief-poster .belief-value { color: var(--orange); }
  .belief-item .belief-desc { font-size: 11px; color: var(--muted); margin-top: 4px; }

  /* ─── Challenge Metadata ─── */
  .challenge-item .ci-meta { font-size: 11px; color: var(--muted); margin-top: 2px; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

  /* ─── Concede Button ─── */
  button.concede { background: var(--orange); }
  button.concede:hover { background: #e67e22; }

  /* ─── Fee Waiver ─── */
  .fee-waiver-group { margin-top: 8px; }
  .fee-waiver-group label { font-size: 12px; color: var(--muted); }
  .fee-waiver-group input { max-width: 120px; display: inline-block; padding: 6px 10px; font-size: 13px; }

  /* ─── Copy Address Button ─── */
  .copy-addr-btn {
    background: none; border: 1px solid var(--border); color: var(--muted);
    padding: 6px 12px; font-size: 12px; border-radius: 6px; cursor: pointer;
  }
  .copy-addr-btn:hover { border-color: var(--accent); color: var(--text); }

  /* ─── Chain Selector ─── */
  .chain-select {
    background: var(--bg); color: var(--text); border: 1px solid var(--border);
    border-radius: 20px; padding: 5px 12px; font-size: 12px; cursor: pointer;
    outline: none; appearance: none; -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%238888a0'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 10px center;
    padding-right: 26px;
  }
  .chain-select:hover { border-color: var(--accent); }
  .chain-select:focus { border-color: var(--accent); }
  .header-right { display: flex; align-items: center; gap: 10px; }
  .chain-note { font-size: 12px; color: var(--muted); text-align: center; margin-bottom: 12px; }

  /* ─── Simple / Advanced Toggle ─── */
  .mode-toggle { display: flex; gap: 0; margin-bottom: 18px; background: var(--bg); border-radius: 8px; overflow: hidden; border: 1px solid var(--border); }
  .mode-btn { flex: 1; padding: 8px; text-align: center; font-size: 13px; font-weight: 500; background: transparent; color: var(--muted); border: none; border-radius: 0; cursor: pointer; transition: all 0.15s; }
  .mode-btn:hover { color: var(--text); }
  .mode-btn.active { background: var(--accent); color: #fff; }
  .advanced-field { display: none; }
  .advanced-field.show { display: block; }

  /* --- Judge Registry --- */
  .judge-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 14px; border: 1px solid var(--border); border-radius: 8px;
    margin-bottom: 8px; font-size: 13px;
  }
  .judge-item .ji-addr { font-family: monospace; font-weight: 500; }
  .judge-item .ji-fee { color: var(--muted); font-size: 12px; margin-top: 2px; }
  .judge-item .ji-bonds { color: var(--muted); font-size: 11px; }
  .judge-item .ji-actions { display: flex; gap: 6px; }
  .judge-item .ji-actions button { padding: 5px 10px; font-size: 12px; }
  .register-judge-form { display: flex; gap: 8px; margin-bottom: 16px; align-items: flex-end; }
  .register-judge-form .form-group { margin-bottom: 0; flex: 1; }
  .register-judge-form button { flex-shrink: 0; height: 40px; }

  /* --- Reject Bond Button --- */
  button.reject { background: var(--orange); }
  button.reject:hover { background: #e67e22; }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>SimpleBond <span>v0.4 — by Futarchy</span></h1>
    <div class="header-right">
      <select id="chainSelect" class="chain-select" onchange="switchChain(this.value)">
        <option value="100">Gnosis</option>
        <option value="137">Polygon</option>
        <option value="1">Ethereum</option>
      </select>
      <div id="walletInfo" class="wallet-info hidden">
        <div class="address" id="walletAddr"></div>
        <div class="chain" id="chainName"></div>
        <div class="disconnect-link" onclick="disconnectWallet()">Sign out</div>
      </div>
      <button id="connectBtn" class="hidden" onclick="showConnectScreen()">Sign In</button>
    </div>
  </header>

  <!-- CONNECTION SCREEN -->
  <div id="connectScreen" class="connect-screen">
    <h2>Put your money where your mouth is</h2>
    <p class="subtitle">Create and challenge bonds with real stakes. No crypto experience needed.</p>
    <div class="connect-options">
      <button class="connect-option connect-option-primary" onclick="connectWeb3Auth()">
        Sign in with Google or Email
      </button>
      <button class="connect-option connect-option-secondary" onclick="connectInjectedWallet()">
        Connect Existing Wallet
      </button>
    </div>
    <div class="browse-link" onclick="browseWithoutWallet()">Browse active bonds without signing in</div>
  </div>

  <!-- MAIN APP (hidden until connected or browsing) -->
  <div id="mainApp" class="hidden">
    <div id="chainNotDeployed" class="hidden" style="text-align:center;padding:40px 20px;color:var(--muted);">
      <h3 style="color:var(--text);margin-bottom:8px;">Not Available on This Chain</h3>
      <p>SimpleBond v0.4 is not deployed on <span id="notDeployedChain">Ethereum</span> yet.</p>
      <p style="margin-top:8px;">Switch to <strong>Gnosis</strong> or <strong>Polygon</strong> to use SimpleBond.</p>
    </div>
    <div id="mainAppContent">
    <div class="tabs">
      <div class="tab active" data-tab="create" onclick="switchTab('create')">Create Bond</div>
      <div class="tab" data-tab="browse" onclick="switchTab('browse')">Browse</div>
      <div class="tab" data-tab="judges" onclick="switchTab('judges')">Judges</div>
      <div class="tab" data-tab="my" onclick="switchTab('my')">My Bonds</div>
      <div class="tab" data-tab="view" onclick="switchTab('view')">View Bond</div>
    </div>

    <!-- CREATE BOND -->
    <div id="tab-create" class="card">
      <h2>Create a Bond</h2>
      <div id="createConnectPrompt" class="connect-prompt">Sign in to create a bond.</div>
      <div id="createForm" class="hidden">
        <!-- Funding Banner -->
        <div id="fundingBanner" class="funding-banner hidden"></div>

        <!-- Simple / Advanced Toggle -->
        <div class="mode-toggle">
          <button class="mode-btn active" data-mode="simple" onclick="setMode('simple')">Simple</button>
          <button class="mode-btn" data-mode="advanced" onclick="setMode('advanced')">Advanced</button>
        </div>

        <div class="form-group">
          <label>Amount (USD)</label>
          <input type="text" id="bondAmount" placeholder="100.00" oninput="onAmountChange()">
          <div id="tokenExplainer" class="hint"></div>
          <div id="tokenBalanceInfo" class="token-balance"></div>
          <div id="approvalStatus" class="approval-status"></div>
        </div>

        <div class="form-group">
          <label>What is this bond for?</label>
          <textarea id="bondMetadata" placeholder="e.g. &quot;All statistical claims in my March 2026 blog post are accurate and properly sourced.&quot;" rows="2"></textarea>
        </div>

        <div class="form-group">
          <label>Judge</label>
          <select id="judgeSelect" onchange="onJudgeSelectChange()">
            <option value="">Select a registered judge...</option>
          </select>
          <div id="judgeMinFeeHint" class="hint">The judge rules on challenges. Pick someone both parties trust.</div>
          <div id="judgeCustomField" class="hidden" style="margin-top:8px;">
            <input type="text" id="judgeAddr" placeholder="0x... or name.eth" oninput="resolveJudgeEns()">
            <div id="judgeEnsHint" class="hint"></div>
          </div>
        </div>

        <div class="form-group">
          <label>Deadline</label>
          <div class="preset-row">
            <button type="button" class="preset" data-days="30" onclick="setDeadline(30)">1 month</button>
            <button type="button" class="preset" data-days="90" onclick="setDeadline(90)">3 months</button>
            <button type="button" class="preset" data-days="180" onclick="setDeadline(180)">6 months</button>
            <button type="button" class="preset" data-days="365" onclick="setDeadline(365)">1 year</button>
          </div>
          <input type="date" id="deadline">
          <div class="hint">Last date someone can challenge this bond.</div>
        </div>

        <!-- Advanced fields -->
        <div class="form-group advanced-field" id="advTokenField">
          <label>Currency</label>
          <div class="token-row">
            <select id="tokenSelect" onchange="onTokenChange()"></select>
            <button type="button" class="secondary add-token-btn" onclick="addCustomToken()">+ Add Custom</button>
          </div>
        </div>

        <div class="form-group advanced-field" id="advChallengeField">
          <label>Challenge Amount</label>
          <input type="text" id="challengeAmount" placeholder="50.0" oninput="this.dataset.userEdited='1'">
          <div class="hint">Amount each challenger must deposit. Default: 50% of bond.</div>
        </div>

        <div class="form-group advanced-field" id="advJudgeFeeField">
          <label>Judge Fee</label>
          <input type="text" id="judgeFee" placeholder="10.0" oninput="this.dataset.userEdited='1'">
          <div class="hint">Fee the judge receives per ruling. Default: 5% of bond.</div>
        </div>

        <div class="form-group advanced-field" id="advAcceptanceDelayField">
          <label>Acceptance Delay</label>
          <div class="preset-row">
            <button type="button" class="preset acceptance-preset" data-adelay="1" onclick="setAcceptanceDelay(1)">1 day</button>
            <button type="button" class="preset acceptance-preset active" data-adelay="3" onclick="setAcceptanceDelay(3)">3 days</button>
            <button type="button" class="preset acceptance-preset" data-adelay="7" onclick="setAcceptanceDelay(7)">7 days</button>
            <button type="button" class="preset acceptance-preset" data-adelay="14" onclick="setAcceptanceDelay(14)">14 days</button>
          </div>
          <div class="hint">Grace period to concede before the judge can rule. Default: 3 days.</div>
        </div>

        <div class="form-group advanced-field" id="advRulingBufferField">
          <label>Ruling Window</label>
          <div class="preset-row">
            <button type="button" class="preset ruling-preset" data-buffer="7" onclick="setRulingBuffer(7)">7 days</button>
            <button type="button" class="preset ruling-preset" data-buffer="14" onclick="setRulingBuffer(14)">14 days</button>
            <button type="button" class="preset ruling-preset active" data-buffer="30" onclick="setRulingBuffer(30)">30 days</button>
          </div>
          <div class="hint">Time for the judge to rule. If missed, everyone is refunded. Default: 30 days.</div>
        </div>

        <div id="createStepper"></div>

        <button id="createBtn" onclick="smartCreateBond()" style="width:100%;margin-top:16px;">Create Bond</button>
        <div id="createMsg"></div>
      </div>
    </div>

    <!-- BROWSE BONDS -->
    <div id="tab-browse" class="card hidden">
      <h2>All Bonds</h2>
      <div id="browseChainNote" class="chain-note"></div>
      <div id="browseLoading" style="color:var(--muted);text-align:center;padding:20px;">
        <span class="spinner"></span> Loading active bonds...
      </div>
      <div id="browseBondsList"></div>
      <div id="browseEmpty" class="hidden" style="text-align:center;padding:20px;color:var(--muted);">
        No active bonds found.
      </div>
    </div>

    <!-- JUDGES -->
    <div id="tab-judges" class="card hidden">
      <h2>Registered Judges</h2>
      <div id="judgeRegisterSection">
        <div id="judgeRegisterPrompt" class="connect-prompt">Sign in to register as a judge.</div>
        <div id="judgeRegisterForm" class="register-judge-form hidden">
          <button onclick="doRegisterJudge()">Register as Judge</button>
          <div class="hint" style="margin-top:6px;">After registering, set per-token minimum fees below.</div>
        </div>
        <div id="judgeOwnStatus" class="hidden" style="margin-bottom:16px;padding:12px;background:var(--bg);border:1px solid var(--border);border-radius:8px;font-size:13px;">
          <div>You are registered as a judge</div>
          <div id="judgeOwnFees" style="color:var(--muted);margin-top:4px;"></div>
          <div style="margin-top:8px;">
            <div class="form-group" style="margin-bottom:8px;">
              <label>Set fee for token</label>
              <select id="judgeTokenSelect" style="margin-bottom:4px;"></select>
              <input type="text" id="judgeNewFee" placeholder="Min fee (in token units, 0 = free)" style="margin-top:4px;">
            </div>
            <div class="btn-row">
              <button class="secondary" onclick="doSetJudgeFee()" style="font-size:12px;padding:6px 12px;">Set Fee</button>
              <button class="danger" onclick="doDeregisterJudge()" style="font-size:12px;padding:6px 12px;">Deregister</button>
            </div>
          </div>
        </div>
      </div>
      <div id="judgesLoading" style="color:var(--muted);text-align:center;padding:20px;">
        <span class="spinner"></span> Loading judges...
      </div>
      <div id="judgesList"></div>
      <div id="judgesEmpty" class="hidden" style="text-align:center;padding:20px;color:var(--muted);">
        No registered judges yet. Be the first!
      </div>
      <div id="judgesMsg"></div>
    </div>

    <!-- MY BONDS -->
    <div id="tab-my" class="card hidden">
      <h2>My Bonds</h2>
      <div id="myBondsConnect" class="connect-prompt">Sign in to see your bonds.</div>
      <div id="myBondsContent" class="hidden">
        <div id="myBondsLoading" style="color:var(--muted);text-align:center;padding:20px;">
          <span class="spinner"></span> Loading your bonds...
        </div>
        <div id="myBondsList"></div>
        <div id="myBondsEmpty" class="hidden" style="text-align:center;padding:20px;color:var(--muted);">
          No bonds found. Create one above!
        </div>
      </div>
    </div>

    <!-- VIEW BOND -->
    <div id="tab-view" class="card hidden">
      <h2>View a Bond</h2>
      <div style="display:flex;gap:8px;margin-bottom:16px;">
        <input type="number" id="bondIdInput" placeholder="Bond ID (e.g. 0)" min="0" style="flex:1">
        <button class="secondary" onclick="loadBond()">Load</button>
      </div>
      <div id="bondDisplay" class="hidden">
        <div class="bond-detail">
          <div class="bond-field">
            <div class="label">Bond ID</div>
            <div class="value" id="bId"></div>
          </div>
          <div class="bond-field">
            <div class="label">Status</div>
            <div class="value" id="bStatus"></div>
          </div>
          <div class="bond-field full">
            <div class="label">Poster</div>
            <div class="value"><a id="bPoster" target="_blank"></a></div>
          </div>
          <div class="bond-field full">
            <div class="label">Judge</div>
            <div class="value"><a id="bJudge" target="_blank"></a></div>
          </div>
          <div class="bond-field full">
            <div class="label">Currency</div>
            <div class="value"><a id="bToken" target="_blank"></a></div>
          </div>
        </div>
        <div class="amounts-grid" style="margin-top:12px;">
          <div class="bond-field">
            <div class="label">Bond Amount</div>
            <div class="value" id="bBondAmount"></div>
          </div>
          <div class="bond-field">
            <div class="label">Challenge Cost</div>
            <div class="value" id="bChallengeAmount"></div>
          </div>
          <div class="bond-field">
            <div class="label">Judge Fee</div>
            <div class="value" id="bJudgeFee"></div>
          </div>
        </div>
        <div class="bond-detail" style="margin-top:12px;">
          <div class="bond-field">
            <div class="label">Challenge Deadline</div>
            <div class="value" id="bDeadline"></div>
          </div>
          <div class="bond-field">
            <div class="label">Acceptance Delay</div>
            <div class="value" id="bAcceptanceDelay"></div>
          </div>
          <div class="bond-field">
            <div class="label">Ruling Window Opens</div>
            <div class="value" id="bRulingStart"></div>
          </div>
          <div class="bond-field">
            <div class="label">Ruling Deadline</div>
            <div class="value" id="bRulingDeadline"></div>
          </div>
          <div class="bond-field full" id="bMetadataRow">
            <div class="label">Claim</div>
            <div class="value" id="bMetadata" style="white-space:pre-wrap;"></div>
          </div>
        </div>

        <!-- Belief Thresholds -->
        <div id="beliefCard" class="belief-card hidden">
          <h3>Implied Belief Thresholds</h3>
          <div class="belief-grid">
            <div class="belief-item belief-challenger">
              <div class="belief-label">Challenger signals</div>
              <div class="belief-value" id="beliefChallenger"></div>
              <div class="belief-desc">chance poster is wrong</div>
            </div>
            <div class="belief-item belief-poster">
              <div class="belief-label">Poster signals</div>
              <div class="belief-value" id="beliefPoster"></div>
              <div class="belief-desc">chance they're wrong</div>
            </div>
          </div>
        </div>

        <!-- Concession Display -->
        <div id="concessionCard" class="concession-card hidden">
          <h3>Poster Conceded</h3>
          <div class="concession-text" id="concessionText"></div>
          <div class="concession-refund" style="margin-top:8px;font-size:13px;color:var(--green);">All funds have been returned — the poster's bond was refunded and all challengers' deposits were automatically sent back.</div>
        </div>

        <!-- Risk/Reward Card (for challengers) -->
        <div id="riskRewardCard" class="risk-reward-card hidden">
          <h3>Challenge this Bond</h3>
          <div class="risk-reward-grid">
            <div class="reward-item">
              <div class="rr-label">If you win</div>
              <div class="rr-value" id="rrWinAmount"></div>
            </div>
            <div class="risk-item">
              <div class="rr-label">Your risk</div>
              <div class="rr-value" id="rrRiskAmount"></div>
            </div>
          </div>
          <div class="rr-note" id="rrNote"></div>
          <div class="form-group" style="margin-top:12px;">
            <label>Your reasoning (stored on-chain)</label>
            <textarea id="challengeMetadata" placeholder="Explain why you think the poster is wrong..." rows="2"></textarea>
          </div>
          <div id="challengeStepper"></div>
          <button id="challengeBtn" onclick="smartChallengeBond()" style="width:100%;">Challenge This Bond</button>
          <div id="challengeMsg"></div>
        </div>

        <!-- Challenge Queue -->
        <div id="challengeQueueSection" class="challenge-queue hidden">
          <h3>Challenge Queue</h3>
          <div id="challengeList"></div>
        </div>

        <div id="bondActions" class="actions hidden">
          <div class="btn-row" id="actionBtns"></div>
        </div>
        <div id="viewMsg"></div>
      </div>
    </div>
  </div>

  <!-- Funding Guide Overlay -->
  <div id="fundingOverlay" class="funding-overlay hidden" onclick="if(event.target===this)closeFundingGuide()">
    <div class="funding-guide">
      <button class="funding-guide-close" onclick="closeFundingGuide()">&times;</button>
      <h3>How to get funds</h3>
      <div id="fundingGuideAddr" style="margin-bottom:16px;"></div>
      <div id="fundingGuideContent"></div>
    </div>
  </div>

  </div><!-- /mainAppContent -->
  <footer>
    <a href="https://github.com/futarchy-fi/simple-bond" target="_blank">GitHub</a>
    &nbsp;&middot;&nbsp; <span id="footerChain">Gnosis Chain</span>
  </footer>
</div>

<script>
// ─── Multi-Chain Config ───────────────────────────────────────────────
const CHAINS = {
  100: {
    name: "Gnosis",
    rpc: "https://rpc.gnosischain.com",
    explorer: "https://gnosisscan.io",
    contract: "0xCe8799303AeaEC861142470d754F74E09EfD1C45",
    deployBlock: 44921914,
    nativeCurrency: { name: "xDAI", symbol: "xDAI", decimals: 18 },
    defaultToken: { address: "0xaf204776c7245bF4147c2612BF6e5972Ee483701", symbol: "sDAI", decimals: 18, displayName: "USD Savings (earns ~8% APY)" },
    wrappedNative: { address: "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d", symbol: "WXDAI", decimals: 18 },
    yieldType: "erc4626",
    tokens: [
      { address: "0xaf204776c7245bF4147c2612BF6e5972Ee483701", symbol: "sDAI", decimals: 18 },
      { address: "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d", symbol: "WXDAI", decimals: 18 },
    ],
    fundingGuide: "gnosis",
    addChainParams: {
      chainId: "0x64",
      chainName: "Gnosis Chain",
      nativeCurrency: { name: "xDAI", symbol: "XDAI", decimals: 18 },
      rpcUrls: ["https://rpc.gnosischain.com"],
      blockExplorerUrls: ["https://gnosisscan.io"],
    },
  },
  137: {
    name: "Polygon",
    rpc: "https://polygon.drpc.org",
    explorer: "https://polygonscan.com",
    contract: "0x6B24380B1980db3e2DfDd2b62f5ed3E7E88DFA43",
    deployBlock: 83608546,
    nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
    defaultToken: { address: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359", symbol: "USDC", decimals: 6, displayName: "USD Coin" },
    wrappedNative: null,
    yieldType: "none",
    tokens: [
      { address: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359", symbol: "USDC", decimals: 6 },
      { address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", symbol: "USDC.e", decimals: 6 },
    ],
    fundingGuide: "polygon",
    addChainParams: {
      chainId: "0x89",
      chainName: "Polygon",
      nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
      rpcUrls: ["https://polygon-rpc.com"],
      blockExplorerUrls: ["https://polygonscan.com"],
    },
  },
  1: {
    name: "Ethereum",
    rpc: "https://eth.llamarpc.com",
    explorer: "https://etherscan.io",
    contract: null, // v4 not deployed on Ethereum yet
    deployBlock: 0,
    nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
    defaultToken: { address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", symbol: "USDC", decimals: 6, displayName: "USD Coin" },
    wrappedNative: null,
    yieldType: "none",
    tokens: [
      { address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", symbol: "USDC", decimals: 6 },
      { address: "0x6B175474E89094C44Da98b954EedeAC495271d0F", symbol: "DAI", decimals: 18 },
    ],
    fundingGuide: "ethereum",
    addChainParams: null, // Ethereum is always available in wallets
  },
};

let activeChainId = 100;
let currentMode = 'simple';
function chain() { return CHAINS[activeChainId]; }

const WEB3AUTH_CLIENT_ID = "BPt1ahKWn4CSezBP6MhIZQQICRcOjt6epWT9jQ45M4sGQyO3jimvzjdBN93ukw2tBR_4PyRBI94FsFLZBfYQFWo";

// Gnosis-specific addresses (kept for wrapping logic)
const SDAI_ADDRESS  = "0xaf204776c7245bF4147c2612BF6e5972Ee483701";
const WXDAI_ADDRESS = "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d";

function friendlyTokenName(addr, symbol) {
  const c = chain();
  if (addr.toLowerCase() === c.defaultToken.address.toLowerCase()) return c.defaultToken.displayName || c.defaultToken.symbol;
  if (c.wrappedNative && addr.toLowerCase() === c.wrappedNative.address.toLowerCase()) return "USD";
  return symbol || "???";
}

function getDefaultTokens() { return chain().tokens; }

// ─── ABIs ─────────────────────────────────────────────────────────────
const BOND_ABI = [
  // v4 functions (includes all v3 + judge registry)
  "function createBond(address token, uint256 bondAmount, uint256 challengeAmount, uint256 judgeFee, address judge, uint256 deadline, uint256 acceptanceDelay, uint256 rulingBuffer, string metadata) returns (uint256)",
  "function challenge(uint256 bondId, string metadata)",
  "function concede(uint256 bondId, string metadata)",
  "function withdrawBond(uint256 bondId)",
  "function ruleForChallenger(uint256 bondId, uint256 feeCharged)",
  "function ruleForPoster(uint256 bondId, uint256 feeCharged)",
  "function claimTimeout(uint256 bondId)",
  // v4 judge registry functions
  "function registerAsJudge()",
  "function deregisterAsJudge()",
  "function setJudgeFee(address token, uint256 minFee)",
  "function setJudgeFees(address[] tokens, uint256[] minFees)",
  "function rejectBond(uint256 bondId)",
  // views
  "function bonds(uint256) view returns (address poster, address judge, address token, uint256 bondAmount, uint256 challengeAmount, uint256 judgeFee, uint256 deadline, uint256 acceptanceDelay, uint256 rulingBuffer, string metadata, bool settled, bool conceded, uint256 currentChallenge, uint256 lastChallengeTime)",
  "function nextBondId() view returns (uint256)",
  "function getChallengeCount(uint256 bondId) view returns (uint256)",
  "function getChallenge(uint256 bondId, uint256 index) view returns (address challenger, uint8 status, string metadata)",
  "function rulingWindowStart(uint256 bondId) view returns (uint256)",
  "function rulingDeadline(uint256 bondId) view returns (uint256)",
  "function judges(address) view returns (bool registered)",
  "function judgeMinFees(address judge, address token) view returns (uint256)",
  "function getJudgeMinFee(address judge, address token) view returns (uint256)",
  // events (v3 + v4)
  "event BondCreated(uint256 indexed bondId, address indexed poster, address indexed judge, address token, uint256 bondAmount, uint256 challengeAmount, uint256 judgeFee, uint256 deadline, uint256 acceptanceDelay, uint256 rulingBuffer, string metadata)",
  "event Challenged(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger, string metadata)",
  "event ClaimConceded(uint256 indexed bondId, address indexed poster, string metadata)",
  "event RuledForChallenger(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger, uint256 feeCharged)",
  "event RuledForPoster(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger, uint256 feeCharged)",
  "event ChallengeRefunded(uint256 indexed bondId, uint256 challengeIndex, address indexed challenger)",
  "event BondWithdrawn(uint256 indexed bondId)",
  "event BondTimedOut(uint256 indexed bondId)",
  // v4 judge registry events
  "event JudgeRegistered(address indexed judge)",
  "event JudgeDeregistered(address indexed judge)",
  "event JudgeFeeUpdated(address indexed judge, address indexed token, uint256 newMinFee)",
  "event BondRejectedByJudge(uint256 indexed bondId, address indexed judge)",
];

const ERC20_ABI = [
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
  "function balanceOf(address) view returns (uint256)",
];

const WXDAI_ABI = [
  ...ERC20_ABI,
  "function deposit() payable",
  "function withdraw(uint256 amount)",
];

const SDAI_ABI = [
  ...ERC20_ABI,
  "function deposit(uint256 assets, address receiver) returns (uint256 shares)",
  "function withdraw(uint256 assets, address receiver, address owner) returns (uint256 shares)",
  "function convertToShares(uint256 assets) view returns (uint256)",
  "function convertToAssets(uint256 shares) view returns (uint256)",
];

// ─── State ────────────────────────────────────────────────────────────
let provider, signer, userAddr, bondContract;
let web3authInstance = null;
let web3authProvider = null;
let connectionType = null; // 'web3auth' | 'injected'
let tokenCache = {};
let approvalCheckTimer = null;
let rulingBufferDays = 30;
let acceptanceDelayDays = 3;
let currentViewBondId = null;
let currentViewBondData = null;
let myBondsLoaded = false;
let browseBondsLoaded = false;

// ─── Token list (localStorage) ────────────────────────────────────────
function getCustomTokens() {
  try { return JSON.parse(localStorage.getItem("bondCustomTokens") || "[]"); } catch (_) { return []; }
}

function saveCustomToken(token) {
  const list = getCustomTokens();
  if (!list.find(t => t.address.toLowerCase() === token.address.toLowerCase())) {
    list.push(token);
    localStorage.setItem("bondCustomTokens", JSON.stringify(list));
  }
}

function getAllTokens() {
  return [...getDefaultTokens(), ...getCustomTokens()];
}

function buildTokenSelect() {
  const sel = document.getElementById("tokenSelect");
  const prev = sel.value;
  sel.innerHTML = "";
  for (const t of getAllTokens()) {
    const opt = document.createElement("option");
    opt.value = t.address;
    const cached = tokenCache[t.address.toLowerCase()];
    const balStr = cached ? ` (${formatBal(cached.balance, cached.decimals)})` : "";
    opt.textContent = `${friendlyTokenName(t.address, t.symbol)}${balStr}`;
    sel.appendChild(opt);
  }
  if (prev && [...sel.options].some(o => o.value.toLowerCase() === prev.toLowerCase())) {
    sel.value = prev;
  }
}

function formatBal(raw, decimals) {
  if (raw == null) return "...";
  const n = parseFloat(ethers.formatUnits(raw, decimals));
  if (n === 0) return "0";
  if (n < 0.01) return "<0.01";
  return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
}

async function addCustomToken() {
  const addr = prompt("Token contract address (0x...):");
  if (!addr || !ethers.isAddress(addr)) { alert("Invalid address"); return; }
  if (getAllTokens().find(t => t.address.toLowerCase() === addr.toLowerCase())) {
    alert("Token already in list"); return;
  }
  const readProvider = provider || new ethers.JsonRpcProvider(chain().rpc);
  const token = new ethers.Contract(addr, ERC20_ABI, readProvider);
  let symbol, decimals;
  try {
    [symbol, decimals] = await Promise.all([token.symbol(), token.decimals()]);
    decimals = Number(decimals);
  } catch (_) {
    alert("Could not read token info. Is this a valid ERC-20 on " + chain().name + "?"); return;
  }
  saveCustomToken({ address: addr, symbol, decimals });
  buildTokenSelect();
  document.getElementById("tokenSelect").value = addr;
  onTokenChange();
}

// ─── Token change ─────────────────────────────────────────────────────
async function onTokenChange() {
  const addr = document.getElementById("tokenSelect").value;
  if (!addr) return;
  updateBalanceDisplay(addr);
  // Refresh judge dropdown to show fees for the new token
  buildJudgeSelect();
  onJudgeSelectChange();
}

function onAmountChange() {
  const val = parseFloat(document.getElementById("bondAmount").value);
  if (val > 0) {
    const challengeEl = document.getElementById("challengeAmount");
    const feeEl = document.getElementById("judgeFee");
    if (!challengeEl.dataset.userEdited) challengeEl.value = (val * 0.5).toFixed(2);
    if (!feeEl.dataset.userEdited) feeEl.value = (val * 0.05).toFixed(2);
  }
  checkApproval();
}

// ─── Simple / Advanced toggle ─────────────────────────────────────────
function setMode(mode) {
  currentMode = mode;
  document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });
  document.querySelectorAll('.advanced-field').forEach(el => {
    el.classList.toggle('show', mode === 'advanced');
  });
  updateTokenExplainer();
  // In simple mode, reset user overrides and re-apply defaults
  if (mode === 'simple') {
    delete document.getElementById("challengeAmount").dataset.userEdited;
    delete document.getElementById("judgeFee").dataset.userEdited;
    onAmountChange();
  }
}

async function updateTokenExplainer() {
  const el = document.getElementById('tokenExplainer');
  if (!el) return;
  if (activeChainId === 100 && currentMode === 'simple') {
    // On Gnosis in simple mode, explain sDAI conversion
    el.textContent = 'Stored as sDAI (loading rate...)';
    try {
      const readProv = new ethers.JsonRpcProvider(chain().rpc);
      const sdaiVault = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, readProv);
      const assetsPerShare = await sdaiVault.convertToAssets(ethers.parseUnits('1', 18));
      const rate = parseFloat(ethers.formatUnits(assetsPerShare, 18)).toFixed(4);
      let suffix = '';
      if (userAddr) {
        const sdaiKey = SDAI_ADDRESS.toLowerCase();
        const cached = tokenCache[sdaiKey];
        const hasSdai = cached && cached.balance > 0n;
        suffix = hasSdai ? ' You have sDAI ready to use.' : ' Your xDAI will be auto-converted.';
      }
      el.innerHTML = `Stored as <b>sDAI</b> — a savings token that earns yield. 1 sDAI = ${rate} xDAI = ${rate} USD.${suffix}`;
    } catch {
      el.textContent = 'Stored as sDAI (earns ~8% APY).';
    }
  } else if (activeChainId !== 100 && currentMode === 'simple') {
    const tok = chain().defaultToken;
    el.textContent = `Stored as ${tok.displayName || tok.symbol} on ${chain().name}.`;
  } else {
    el.textContent = '';
  }
}

async function updateBalanceDisplay(tokenAddr) {
  const el = document.getElementById("tokenBalanceInfo");
  if (!tokenAddr) { el.innerHTML = ""; return; }
  if (!userAddr) { el.innerHTML = ""; return; }
  const key = tokenAddr.toLowerCase();

  // Use cached data if available (refreshAllBalances already fetched it)
  if (tokenCache[key]) {
    const c = tokenCache[key];
    const bal = formatBal(c.balance, c.decimals);
    const display = friendlyTokenName(tokenAddr, c.symbol);
    el.innerHTML = `Balance: <span class="bal">${bal} ${display}</span>`;
    return;
  }

  el.innerHTML = "Loading balance...";
  try {
    const p = signer || new ethers.JsonRpcProvider(chain().rpc);
    const token = new ethers.Contract(tokenAddr, ERC20_ABI, p);
    const [balance, allowance, decimals, symbol] = await Promise.all([
      token.balanceOf(userAddr),
      token.allowance(userAddr, chain().contract),
      token.decimals(),
      token.symbol(),
    ]);
    tokenCache[key] = { symbol, decimals: Number(decimals), balance, allowance };
    const bal = formatBal(balance, Number(decimals));
    const display = friendlyTokenName(tokenAddr, symbol);
    el.innerHTML = `Balance: <span class="bal">${bal} ${display}</span>`;
    buildTokenSelect();
    document.getElementById("tokenSelect").value = tokenAddr;
  } catch (err) {
    el.innerHTML = `<span style="color:var(--red)">Could not load balance</span>`;
  }
}

// ─── Auto-check approval ──────────────────────────────────────────────
async function checkApproval() {
  clearTimeout(approvalCheckTimer);
  approvalCheckTimer = setTimeout(_doCheckApproval, 300);
}

async function _doCheckApproval() {
  const statusEl = document.getElementById("approvalStatus");
  const tokenAddr = getSelectedToken();
  const amountStr = document.getElementById("bondAmount").value.trim();

  if (!userAddr || !tokenAddr || !amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) {
    statusEl.innerHTML = "";
    return;
  }

  const key = tokenAddr.toLowerCase();
  let cached = tokenCache[key];

  if (!cached) {
    try {
      const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer || new ethers.JsonRpcProvider(chain().rpc));
      const [balance, allowance, decimals, symbol] = await Promise.all([
        token.balanceOf(userAddr),
        token.allowance(userAddr, chain().contract),
        token.decimals(),
        token.symbol(),
      ]);
      cached = { symbol, decimals: Number(decimals), balance, allowance };
      tokenCache[key] = cached;
    } catch (_) { return; }
  }

  try {
    const amount = ethers.parseUnits(amountStr, cached.decimals);
    if (cached.balance < amount) {
      if (activeChainId === 100) {
        // Check if user has WXDAI or xDAI that can be wrapped (Gnosis only)
        const totalAvailable = await getTotalAvailableFunds();
        if (totalAvailable >= amount) {
          statusEl.innerHTML = `<span class="approval-ok">Funds available (will auto-convert)</span>`;
        } else {
          const need = ethers.formatUnits(amount - totalAvailable, 18);
          statusEl.innerHTML = `<span class="approval-need">Need ${parseFloat(need).toLocaleString(undefined, {maximumFractionDigits: 2})} more USD — <span class="browse-link" onclick="openFundingGuide()" style="font-size:inherit;">How to get funds</span></span>`;
        }
      } else {
        const need = ethers.formatUnits(amount - cached.balance, cached.decimals);
        statusEl.innerHTML = `<span class="approval-need">Need ${parseFloat(need).toLocaleString(undefined, {maximumFractionDigits: 2})} more ${cached.symbol} — <span class="browse-link" onclick="openFundingGuide()" style="font-size:inherit;">How to get funds</span></span>`;
      }
      return;
    }
    if (cached.allowance >= amount) {
      statusEl.innerHTML = `<span class="approval-ok">Ready to create</span>`;
    } else {
      statusEl.innerHTML = `<span class="approval-ok">Will auto-approve</span>`;
    }
  } catch (_) {
    statusEl.innerHTML = "";
  }
}

// ─── Get total available funds across xDAI/WXDAI/sDAI (Gnosis only) ─
async function getTotalAvailableFunds() {
  if (!userAddr || activeChainId !== 100) return 0n;
  const readProv = signer || new ethers.JsonRpcProvider(chain().rpc);
  try {
    const [nativeBalance, wxdaiContract, sdaiContract] = [
      await (provider || new ethers.JsonRpcProvider(chain().rpc)).getBalance(userAddr),
      new ethers.Contract(WXDAI_ADDRESS, ERC20_ABI, readProv),
      new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, readProv),
    ];
    const [wxdaiBal, sdaiBal, sdaiAssets] = await Promise.all([
      wxdaiContract.balanceOf(userAddr),
      sdaiContract.balanceOf(userAddr),
      sdaiContract.convertToAssets(await sdaiContract.balanceOf(userAddr)).catch(() => 0n),
    ]);
    // sDAI balance is already in "assets" terms via convertToAssets
    return nativeBalance + wxdaiBal + sdaiAssets;
  } catch (_) {
    return 0n;
  }
}

// ─── Wallet Connection ────────────────────────────────────────────────

function showConnectScreen() {
  document.getElementById("connectScreen").classList.remove("hidden");
  document.getElementById("mainApp").classList.add("hidden");
}

async function initWeb3Auth() {
  if (WEB3AUTH_CLIENT_ID === "YOUR_WEB3AUTH_CLIENT_ID") return null;
  try {
    const { Web3Auth } = window.Modal || window.Web3auth?.Modal || {};
    if (!Web3Auth) {
      console.warn("Web3Auth Modal not loaded from CDN");
      return null;
    }
    const c = chain();
    const web3auth = new Web3Auth({
      clientId: WEB3AUTH_CLIENT_ID,
      web3AuthNetwork: "sapphire_mainnet",
      chainConfig: {
        chainNamespace: "eip155",
        chainId: "0x" + activeChainId.toString(16),
        rpcTarget: c.rpc,
        displayName: c.name,
        blockExplorerUrl: c.explorer,
        ticker: c.nativeCurrency.symbol,
        tickerName: c.nativeCurrency.name,
      },
      uiConfig: {
        theme: "dark",
        appName: "SimpleBond",
      },
    });
    await web3auth.initModal();
    web3authInstance = web3auth;
    return web3auth;
  } catch (err) {
    console.warn("Web3Auth init failed:", err);
    return null;
  }
}

async function connectWeb3Auth() {
  try {
    if (!web3authInstance) {
      const inst = await initWeb3Auth();
      if (!inst) {
        alert("Web3Auth is not configured yet. Please set WEB3AUTH_CLIENT_ID in the page source, or use 'Connect Existing Wallet'.");
        return;
      }
    }
    const w3aProvider = await web3authInstance.connect();
    if (!w3aProvider) return;
    web3authProvider = w3aProvider;
    connectionType = 'web3auth';
    provider = new ethers.BrowserProvider(w3aProvider);
    signer = await provider.getSigner();
    userAddr = await signer.getAddress();
    bondContract = new ethers.Contract(chain().contract, BOND_ABI, signer);
    onWalletConnected();
  } catch (err) {
    console.error("Web3Auth connect error:", err);
    if (err.message && !err.message.includes("User closed")) {
      alert("Sign-in failed: " + (err.message || err));
    }
  }
}

async function connectInjectedWallet() {
  if (!window.ethereum) {
    alert("No wallet detected. Install MetaMask or Rabby to use this option.");
    return;
  }
  try {
    await window.ethereum.request({ method: "eth_requestAccounts" });
    provider = new ethers.BrowserProvider(window.ethereum);
    const network = await provider.getNetwork();
    const walletChainId = Number(network.chainId);

    // Auto-detect: if wallet is on a supported chain, switch to it
    if (CHAINS[walletChainId]) {
      activeChainId = walletChainId;
      document.getElementById("chainSelect").value = String(activeChainId);
    } else {
      // Wallet on unsupported chain — switch to active chain
      await switchWalletChain(activeChainId);
      provider = new ethers.BrowserProvider(window.ethereum);
    }

    signer = await provider.getSigner();
    userAddr = await signer.getAddress();
    connectionType = 'injected';
    bondContract = new ethers.Contract(chain().contract, BOND_ABI, signer);
    onWalletConnected();
  } catch (err) {
    console.error("Injected wallet error:", err);
    alert("Connection failed: " + (err.message || err));
  }
}

async function switchWalletChain(chainId) {
  const c = CHAINS[chainId];
  const hexId = "0x" + chainId.toString(16);
  try {
    await window.ethereum.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: hexId }],
    });
  } catch (switchErr) {
    if (switchErr.code === 4902 && c.addChainParams) {
      await window.ethereum.request({
        method: "wallet_addEthereumChain",
        params: [c.addChainParams],
      });
    } else { throw switchErr; }
  }
}

async function switchChain(chainIdStr) {
  const newChainId = Number(chainIdStr);
  if (!CHAINS[newChainId]) return;
  activeChainId = newChainId;

  // Check if chain has a deployed contract
  const notDeployedEl = document.getElementById("chainNotDeployed");
  const mainAppContent = document.getElementById("mainAppContent");
  if (!chain().contract) {
    if (notDeployedEl) {
      notDeployedEl.classList.remove("hidden");
      document.getElementById("notDeployedChain").textContent = chain().name;
    }
    if (mainAppContent) mainAppContent.classList.add("hidden");
  } else {
    if (notDeployedEl) notDeployedEl.classList.add("hidden");
    if (mainAppContent) mainAppContent.classList.remove("hidden");
  }

  // Update read provider for non-connected browsing
  tokenCache = {};
  myBondsLoaded = false;
  browseBondsLoaded = false;
  judgesLoaded = false;
  judgesList = [];

  // Update footer
  document.getElementById("footerChain").textContent = chain().name;

  if (signer && connectionType === 'injected' && window.ethereum) {
    try {
      await switchWalletChain(newChainId);
      provider = new ethers.BrowserProvider(window.ethereum);
      signer = await provider.getSigner();
      bondContract = new ethers.Contract(chain().contract, BOND_ABI, signer);
      refreshAllBalances();
    } catch (err) {
      console.warn("Chain switch failed:", err);
      // Revert selector
      document.getElementById("chainSelect").value = String(activeChainId);
    }
  } else if (signer && connectionType === 'web3auth' && web3authInstance) {
    try {
      const c = chain();
      await web3authInstance.addChain({
        chainNamespace: "eip155",
        chainId: "0x" + newChainId.toString(16),
        rpcTarget: c.rpc,
        displayName: c.name,
        blockExplorerUrl: c.explorer,
        ticker: c.nativeCurrency.symbol,
        tickerName: c.nativeCurrency.name,
      });
      await web3authInstance.switchChain({ chainId: "0x" + newChainId.toString(16) });
      provider = new ethers.BrowserProvider(web3authInstance.provider);
      signer = await provider.getSigner();
      bondContract = new ethers.Contract(chain().contract, BOND_ABI, signer);
      refreshAllBalances();
    } catch (err) {
      console.warn("Web3Auth chain switch failed:", err);
    }
  }

  // Update UI elements
  document.getElementById("chainName").textContent = chain().name;
  buildTokenSelect();
  const sel = document.getElementById("tokenSelect");
  sel.value = chain().defaultToken.address;
  onTokenChange();
  updateTokenExplainer();
  loadJudgeSelectOnCreate();

  // Update URL
  const url = new URL(window.location);
  const chainParam = Object.entries({gnosis: 100, polygon: 137, ethereum: 1}).find(([,v]) => v === newChainId);
  if (chainParam) url.searchParams.set("chain", chainParam[0]);
  history.replaceState(null, "", url);

  // Reload browse/my/judges tabs if visible
  const activeTab = document.querySelector(".tab.active");
  if (activeTab) {
    if (activeTab.dataset.tab === "browse") loadBrowseBonds();
    if (activeTab.dataset.tab === "my" && userAddr) loadMyBonds();
    if (activeTab.dataset.tab === "judges") loadJudges();
  }
}

function onWalletConnected() {
  document.getElementById("connectScreen").classList.add("hidden");
  document.getElementById("mainApp").classList.remove("hidden");
  document.getElementById("connectBtn").classList.add("hidden");
  document.getElementById("walletInfo").classList.remove("hidden");
  document.getElementById("walletAddr").textContent = short(userAddr);
  document.getElementById("chainName").textContent = chain().name;
  document.getElementById("createConnectPrompt").classList.add("hidden");
  document.getElementById("createForm").classList.remove("hidden");
  document.getElementById("myBondsConnect").classList.add("hidden");
  document.getElementById("myBondsContent").classList.remove("hidden");

  if (!document.getElementById("deadline").value) {
    const d = new Date(Date.now() + 90 * 86400000);
    document.getElementById("deadline").value = d.toISOString().slice(0, 10);
  }

  tokenCache = {};
  judgesLoaded = false;
  refreshAllBalances();
  loadJudgeSelectOnCreate();

  // Set up injected wallet event listeners
  if (connectionType === 'injected' && window.ethereum) {
    window.ethereum.on("accountsChanged", () => { saveForm(); window.location.reload(); });
    window.ethereum.on("chainChanged", (hexChainId) => {
      const newId = parseInt(hexChainId, 16);
      if (CHAINS[newId]) {
        activeChainId = newId;
        document.getElementById("chainSelect").value = String(newId);
        document.getElementById("chainName").textContent = chain().name;
        document.getElementById("footerChain").textContent = chain().name;
        tokenCache = {};
        myBondsLoaded = false;
        browseBondsLoaded = false;
        provider = new ethers.BrowserProvider(window.ethereum);
        provider.getSigner().then(s => {
          signer = s;
          bondContract = new ethers.Contract(chain().contract, BOND_ABI, signer);
          buildTokenSelect();
          document.getElementById("tokenSelect").value = chain().defaultToken.address;
          refreshAllBalances();
        });
      }
    });
  }
}

async function disconnectWallet() {
  if (connectionType === 'web3auth' && web3authInstance) {
    try { await web3authInstance.logout(); } catch (_) {}
    web3authProvider = null;
  }
  provider = null;
  signer = null;
  userAddr = null;
  bondContract = null;
  connectionType = null;
  tokenCache = {};
  myBondsLoaded = false;

  document.getElementById("walletInfo").classList.add("hidden");
  document.getElementById("connectBtn").classList.remove("hidden");
  document.getElementById("connectScreen").classList.remove("hidden");
  document.getElementById("mainApp").classList.add("hidden");
}

function browseWithoutWallet() {
  document.getElementById("connectScreen").classList.add("hidden");
  document.getElementById("mainApp").classList.remove("hidden");
  document.getElementById("connectBtn").classList.remove("hidden");
  switchTab("browse");
}

// ─── Onboarding State Machine ─────────────────────────────────────────
async function checkOnboardingState() {
  if (!userAddr) return;
  const banner = document.getElementById("fundingBanner");

  try {
    const readProv = provider || new ethers.JsonRpcProvider(chain().rpc);
    const c = chain();

    if (activeChainId === 100) {
      // Gnosis: check sDAI/WXDAI/xDAI
      const nativeBal = await readProv.getBalance(userAddr);
      const wxdai = new ethers.Contract(WXDAI_ADDRESS, ERC20_ABI, signer || readProv);
      const sdai = new ethers.Contract(SDAI_ADDRESS, ERC20_ABI, signer || readProv);
      const [wxdaiBal, sdaiBal] = await Promise.all([
        wxdai.balanceOf(userAddr),
        sdai.balanceOf(userAddr),
      ]);

      const hasNative = nativeBal > ethers.parseEther("0.01");
      const hasWxdai = wxdaiBal > ethers.parseEther("0.01");
      const hasSdai = sdaiBal > ethers.parseEther("0.01");

      if (hasSdai) { banner.classList.add("hidden"); return; }

      if (hasNative || hasWxdai) {
        banner.className = "funding-banner";
        banner.classList.remove("hidden");
        const wxdaiAmt = formatBal(wxdaiBal, 18);
        const nativeAmt = formatBal(nativeBal, 18);
        const totalDesc = [hasWxdai ? wxdaiAmt + ' USD' : '', hasNative ? nativeAmt + ' xDAI' : ''].filter(Boolean).join(' + ');
        banner.innerHTML = `
          <p style="margin:0;">You have ${totalDesc}.
            <span class="browse-link" onclick="convertAllToSdai()" style="font-size:inherit;">Convert to USD Savings (earns ~8% APY)</span>
          </p>`;
        return;
      }
    } else {
      // Polygon/Ethereum: check default token balance
      const tokenContract = new ethers.Contract(c.defaultToken.address, ERC20_ABI, signer || readProv);
      const tokenBal = await tokenContract.balanceOf(userAddr);
      const threshold = c.defaultToken.decimals === 6 ? 10000n : ethers.parseEther("0.01"); // $0.01 for 6-decimal
      if (tokenBal > threshold) { banner.classList.add("hidden"); return; }
    }

    // No funds — show a subtle hint
    banner.className = "funding-banner";
    banner.classList.remove("hidden");
    banner.innerHTML = `
      <p style="margin:0;">No ${c.defaultToken.symbol} yet.
        <span class="browse-link" onclick="openFundingGuide()" style="font-size:inherit;">How to get funds</span>
        &nbsp;&middot;&nbsp;
        <span class="browse-link" onclick="copyAddress()" style="font-size:inherit;">Copy wallet address</span>
      </p>`;
  } catch (err) {
    console.warn("Onboarding check failed:", err);
    banner.classList.add("hidden");
  }
}

function copyAddress() {
  if (!userAddr) return;
  navigator.clipboard.writeText(userAddr).then(() => {
    const btn = event.target;
    const orig = btn.textContent;
    btn.textContent = "Copied!";
    setTimeout(() => { btn.textContent = orig; }, 1500);
  }).catch(() => { prompt("Copy your wallet address:", userAddr); });
}

async function convertAllToSdai() {
  if (!signer || !userAddr) return;
  const banner = document.getElementById("fundingBanner");
  const stepperEl = document.createElement("div");
  banner.innerHTML = "";
  banner.appendChild(stepperEl);

  try {
    const readProv = provider || new ethers.JsonRpcProvider(chain().rpc);
    const nativeBal = await readProv.getBalance(userAddr);
    const wxdaiContract = new ethers.Contract(WXDAI_ADDRESS, WXDAI_ABI, signer);
    const sdaiContract = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, signer);
    const wxdaiBal = await wxdaiContract.balanceOf(userAddr);

    const steps = [];
    let wxdaiToDeposit = wxdaiBal;

    // Keep 0.01 xDAI for gas
    const gasReserve = ethers.parseEther("0.01");
    const wrapAmount = nativeBal > gasReserve ? nativeBal - gasReserve : 0n;

    if (wrapAmount > 0n) {
      steps.push("Wrap xDAI to WXDAI");
    }
    steps.push("Approve WXDAI");
    steps.push("Deposit to USD Savings");

    renderTxStepper(stepperEl, steps);
    let stepIdx = 0;

    // Step: Wrap xDAI
    if (wrapAmount > 0n) {
      updateStepStatus(stepperEl, stepIdx, 'active');
      const wrapTx = await wxdaiContract.deposit({ value: wrapAmount });
      await waitForTx(wrapTx);
      wxdaiToDeposit += wrapAmount;
      updateStepStatus(stepperEl, stepIdx, 'done');
      stepIdx++;
    }

    // Step: Approve WXDAI for sDAI vault
    updateStepStatus(stepperEl, stepIdx, 'active');
    await ensureApproval(WXDAI_ADDRESS, wxdaiToDeposit, SDAI_ADDRESS);
    updateStepStatus(stepperEl, stepIdx, 'done');
    stepIdx++;

    // Step: Deposit to sDAI
    updateStepStatus(stepperEl, stepIdx, 'active');
    const depositTx = await sdaiContract.deposit(wxdaiToDeposit, userAddr);
    await waitForTx(depositTx);
    updateStepStatus(stepperEl, stepIdx, 'done');

    // Refresh
    tokenCache = {};
    await refreshAllBalances();
    banner.classList.add("hidden");
    showMsg(document.getElementById("createMsg"), "Converted to USD Savings! Ready to create bonds.", "success");
  } catch (err) {
    banner.innerHTML = `<div class="msg msg-error">Conversion failed: ${err.reason || err.message}</div>`;
  }
}

// ─── Funding Guide ────────────────────────────────────────────────────
function openFundingGuide() {
  const overlay = document.getElementById("fundingOverlay");
  const addrEl = document.getElementById("fundingGuideAddr");
  const contentEl = document.getElementById("fundingGuideContent");
  if (userAddr) {
    addrEl.innerHTML = `
      <div style="font-size:13px;color:var(--muted);margin-bottom:4px;">Your wallet address (${chain().name}):</div>
      <div style="display:flex;gap:8px;align-items:center;">
        <code style="font-size:13px;color:var(--accent);word-break:break-all;flex:1;">${userAddr}</code>
        <button class="copy-addr-btn" onclick="copyAddress()">Copy</button>
      </div>`;
  } else {
    addrEl.innerHTML = `<div style="font-size:13px;color:var(--muted);">Sign in first to see your wallet address.</div>`;
  }

  // Chain-specific funding content
  const guides = {
    gnosis: `
      <div class="funding-option">
        <h4>Ask someone to send you funds</h4>
        <p>Share your wallet address with someone who already has xDAI on Gnosis Chain.</p>
        <div class="fo-fee fo-fee-free">Fee: $0</div>
      </div>
      <div class="funding-option">
        <h4>Send from another wallet</h4>
        <p>If you have xDAI in MetaMask, Rabby, or any wallet on Gnosis Chain, send it to the address above.</p>
        <div class="fo-fee fo-fee-free">Fee: &lt;$0.01 (gas only)</div>
      </div>
      <div class="funding-option">
        <h4>Bridge from Ethereum</h4>
        <p>Have DAI on Ethereum? Bridge it to Gnosis Chain where it becomes xDAI.</p>
        <div class="fo-fee fo-fee-low">Fee: Ethereum gas (~$1-5)</div>
        <ol class="fo-steps">
          <li>Go to <a href="https://bridge.gnosischain.com" target="_blank" style="color:var(--accent)">bridge.gnosischain.com</a></li>
          <li>Connect your Ethereum wallet</li>
          <li>Bridge DAI &rarr; Gnosis Chain</li>
          <li>Takes ~5 minutes</li>
        </ol>
      </div>
      <div class="funding-option">
        <h4>Buy with fiat</h4>
        <p>Purchase xDAI directly with a bank transfer or card.</p>
        <ol class="fo-steps">
          <li><a href="https://www.mtpelerin.com/buy-xdai" target="_blank" style="color:var(--accent)">Mt Pelerin</a> &mdash; bank transfer, low fees</li>
          <li><a href="https://ramp.network" target="_blank" style="color:var(--accent)">Ramp Network</a> &mdash; card or bank transfer</li>
        </ol>
      </div>`,
    polygon: `
      <div class="funding-option">
        <h4>Send USDC from an exchange</h4>
        <p>Most major exchanges (Coinbase, Binance, Kraken) support direct USDC withdrawal to Polygon.</p>
        <div class="fo-fee fo-fee-free">Fee: varies by exchange</div>
        <ol class="fo-steps">
          <li>Buy USDC on your exchange</li>
          <li>Withdraw to Polygon network</li>
          <li>Paste the wallet address shown above</li>
        </ol>
      </div>
      <div class="funding-option">
        <h4>Send from another wallet</h4>
        <p>If you have USDC in MetaMask or any wallet on Polygon, send it to the address above.</p>
        <div class="fo-fee fo-fee-free">Fee: &lt;$0.01 (gas only)</div>
      </div>
      <div class="funding-option">
        <h4>Bridge from Ethereum</h4>
        <p>Bridge USDC from Ethereum to Polygon via the official Polygon Bridge.</p>
        <div class="fo-fee fo-fee-low">Fee: Ethereum gas (~$1-5)</div>
        <ol class="fo-steps">
          <li>Go to <a href="https://portal.polygon.technology/bridge" target="_blank" style="color:var(--accent)">portal.polygon.technology/bridge</a></li>
          <li>Bridge USDC from Ethereum &rarr; Polygon</li>
        </ol>
      </div>`,
    ethereum: `
      <div class="funding-option">
        <h4>Send USDC from an exchange</h4>
        <p>All major exchanges support direct USDC withdrawal on Ethereum.</p>
        <div class="fo-fee fo-fee-free">Fee: varies by exchange</div>
        <ol class="fo-steps">
          <li>Buy USDC on your exchange</li>
          <li>Withdraw on Ethereum network</li>
          <li>Paste the wallet address shown above</li>
        </ol>
      </div>
      <div class="funding-option">
        <h4>Send from another wallet</h4>
        <p>If you have USDC in MetaMask or any Ethereum wallet, send it to the address above.</p>
        <div class="fo-fee fo-fee-low">Fee: Ethereum gas (~$1-5)</div>
      </div>
      <div class="funding-option">
        <h4>Buy with debit card</h4>
        <p>Purchase USDC directly with a card.</p>
        <ol class="fo-steps">
          <li><a href="https://ramp.network" target="_blank" style="color:var(--accent)">Ramp Network</a> &mdash; card or bank transfer</li>
          <li><a href="https://www.moonpay.com" target="_blank" style="color:var(--accent)">MoonPay</a> &mdash; card purchase</li>
        </ol>
      </div>`,
  };
  contentEl.innerHTML = guides[chain().fundingGuide] || guides.ethereum;
  overlay.classList.remove("hidden");
}

function closeFundingGuide() {
  document.getElementById("fundingOverlay").classList.add("hidden");
  // Refresh balances in case user funded while guide was open
  if (userAddr) {
    tokenCache = {};
    refreshAllBalances();
  }
}

function getSelectedToken() {
  if (currentMode === 'simple') return chain().defaultToken.address;
  return document.getElementById("tokenSelect").value || chain().defaultToken.address;
}

// ─── Transaction Stepper ──────────────────────────────────────────────
function renderTxStepper(container, steps) {
  container.innerHTML = `<div class="tx-stepper">${steps.map((label, i) =>
    `<div class="tx-step" data-step="${i}">
      <div class="step-num">${i + 1}</div>
      <div class="step-label">${label}</div>
    </div>`
  ).join("")}</div>`;
}

function updateStepStatus(container, idx, status) {
  const step = container.querySelector(`[data-step="${idx}"]`);
  if (!step) return;
  step.className = `tx-step tx-step-${status}`;
  const numEl = step.querySelector(".step-num");
  if (status === 'active') {
    numEl.innerHTML = '<span class="spinner"></span>';
  } else if (status === 'done') {
    numEl.innerHTML = '\u2713';
  }
}

// ─── Robust tx.wait() — retries on null receipt ─────────────────────
async function waitForTx(tx, retries = 5) {
  for (let i = 0; i < retries; i++) {
    try {
      const receipt = await tx.wait();
      if (receipt) return receipt;
    } catch (err) {
      if (i === retries - 1) throw err;
      // RPC returned null — wait and retry
      await new Promise(r => setTimeout(r, 3000 * (i + 1)));
    }
  }
}

// ─── Token Wrapping Helpers ───────────────────────────────────────────
async function wrapXdaiToWxdai(amount) {
  const wxdai = new ethers.Contract(WXDAI_ADDRESS, WXDAI_ABI, signer);
  const tx = await wxdai.deposit({ value: amount });
  await waitForTx(tx);
}

async function wrapWxdaiToSdai(amount) {
  const sdai = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, signer);
  const tx = await sdai.deposit(amount, userAddr);
  await waitForTx(tx);
}

async function ensureApproval(tokenAddr, amount, spender) {
  const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
  const allowance = await token.allowance(userAddr, spender);
  if (allowance >= amount) return;
  // Approve max so user doesn't need to re-approve for future txs
  const tx = await token.approve(spender, ethers.MaxUint256);
  const receipt = await waitForTx(tx);
  if (!receipt) throw new Error("Approval transaction failed — please try again");
  // Update cache
  const key = tokenAddr.toLowerCase();
  if (tokenCache[key]) {
    tokenCache[key].allowance = ethers.MaxUint256;
  }
}

async function getBalance(tokenAddr) {
  const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer || new ethers.JsonRpcProvider(chain().rpc));
  return await token.balanceOf(userAddr);
}

function needsWrapping(tokenAddr) {
  return activeChainId === 100 && tokenAddr.toLowerCase() === SDAI_ADDRESS.toLowerCase();
}

function buildTxSteps(tokenAddr, amountWei) {
  // Returns an array of step descriptors
  // This is determined dynamically when smartCreateBond runs
  return []; // Placeholder — actual logic in smartCreateBond
}

// ─── Smart Create Bond (with stepper) ─────────────────────────────────
async function smartCreateBond() {
  if (!signer) return;
  const btn = document.getElementById("createBtn");
  const msg = document.getElementById("createMsg");
  const stepperEl = document.getElementById("createStepper");

  try {
    const tokenAddr = getSelectedToken();
    if (!ethers.isAddress(tokenAddr)) { showMsg(msg, "Invalid currency", "error"); return; }

    const bondAmountStr = document.getElementById("bondAmount").value.trim();
    if (!bondAmountStr || isNaN(bondAmountStr) || parseFloat(bondAmountStr) <= 0) {
      showMsg(msg, "Enter a valid amount", "error"); return;
    }

    // Get judge address from dropdown or custom input
    const judgeSelectVal = document.getElementById("judgeSelect").value;
    let judgeAddr;
    if (judgeSelectVal === "__custom__") {
      const judgeInput = document.getElementById("judgeAddr");
      judgeAddr = judgeInput.dataset.resolvedAddr || judgeInput.value.trim();
      if (!ethers.isAddress(judgeAddr) && (judgeAddr.endsWith('.eth') || judgeAddr.endsWith('.xyz') || judgeAddr.endsWith('.id'))) {
        try {
          const resolved = await ensProvider.resolveName(judgeAddr);
          if (resolved) judgeAddr = resolved;
        } catch (_) {}
      }
    } else {
      judgeAddr = judgeSelectVal;
    }
    if (!ethers.isAddress(judgeAddr)) { showMsg(msg, "Select a judge or enter a valid address", "error"); return; }

    const deadlineStr = document.getElementById("deadline").value;
    if (!deadlineStr) { showMsg(msg, "Set a deadline", "error"); return; }

    // Get challenge amount and judge fee — default to 50% and 5% of bond if empty
    const bondVal = parseFloat(bondAmountStr);
    let challengeAmountStr = document.getElementById("challengeAmount").value.trim();
    let judgeFeeStr = document.getElementById("judgeFee").value.trim();
    if (!challengeAmountStr) challengeAmountStr = (bondVal * 0.5).toFixed(2);
    if (!judgeFeeStr) judgeFeeStr = (bondVal * 0.05).toFixed(2);

    if (!challengeAmountStr || isNaN(challengeAmountStr) || parseFloat(challengeAmountStr) <= 0) {
      showMsg(msg, "Enter a valid challenge amount", "error"); return;
    }
    if (!judgeFeeStr || isNaN(judgeFeeStr) || parseFloat(judgeFeeStr) < 0) {
      showMsg(msg, "Enter a valid judge fee", "error"); return;
    }

    // Determine decimals and convert amounts
    const tokenContract = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
    const decimals = Number(await tokenContract.decimals());
    let bondAmount, challengeAmount, judgeFee;

    if (needsWrapping(tokenAddr)) {
      // sDAI: user enters USD value, convert to sDAI shares
      const sdaiVault = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, signer);
      const bondAssets = ethers.parseUnits(bondAmountStr, 18); // USD value in WXDAI terms
      const challengeAssets = ethers.parseUnits(challengeAmountStr, 18);
      const feeAssets = ethers.parseUnits(judgeFeeStr, 18);
      bondAmount = await sdaiVault.convertToShares(bondAssets);
      challengeAmount = await sdaiVault.convertToShares(challengeAssets);
      judgeFee = await sdaiVault.convertToShares(feeAssets);
    } else {
      bondAmount = ethers.parseUnits(bondAmountStr, decimals);
      challengeAmount = ethers.parseUnits(challengeAmountStr, decimals);
      judgeFee = ethers.parseUnits(judgeFeeStr, decimals);
    }
    const deadline = BigInt(Math.floor(new Date(deadlineStr + "T23:59:59Z").getTime() / 1000));
    const acceptanceDelay = BigInt(acceptanceDelayDays * 86400);
    const rulingBuffer = BigInt(rulingBufferDays * 86400);

    if (deadline <= BigInt(Math.floor(Date.now() / 1000))) {
      showMsg(msg, "Deadline must be in the future", "error"); return;
    }
    if (judgeFee > challengeAmount) {
      showMsg(msg, "Judge fee can't exceed the challenge amount", "error"); return;
    }
    if (judgeFee > challengeAmount) {
      showMsg(msg, "Judge fee must be <= challenge amount", "error"); return;
    }

    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Processing...';

    // Build dynamic steps based on user's balance state
    const steps = [];
    const isSdai = needsWrapping(tokenAddr);
    let sdaiBal = 0n;

    if (isSdai) {
      // Gnosis sDAI: auto-wrap from xDAI/WXDAI if needed
      sdaiBal = await getBalance(SDAI_ADDRESS);
      if (sdaiBal < bondAmount) {
        const wxdaiBal = await getBalance(WXDAI_ADDRESS);
        const nativeBal = await (provider || new ethers.JsonRpcProvider(chain().rpc)).getBalance(userAddr);

        // Convert sDAI share deficit to WXDAI (assets) needed
        const sdaiVault = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, signer);
        const sdaiShareDeficit = bondAmount - sdaiBal;
        const wxdaiNeededRaw = await sdaiVault.convertToAssets(sdaiShareDeficit);
        const wxdaiNeeded = wxdaiNeededRaw + (wxdaiNeededRaw / 500n); // 0.2% buffer for rounding

        if (wxdaiBal < wxdaiNeeded) {
          const wxdaiDeficit = wxdaiNeeded - wxdaiBal;
          const gasReserve = ethers.parseEther("0.01");
          if (nativeBal > gasReserve + wxdaiDeficit) {
            steps.push({ label: "Wrap xDAI to WXDAI", action: "wrapXdai", amount: wxdaiDeficit });
          } else if (nativeBal > gasReserve) {
            steps.push({ label: "Wrap xDAI to WXDAI", action: "wrapXdai", amount: nativeBal - gasReserve });
          } else {
            showMsg(msg, "Insufficient funds. Buy some USD first.", "error");
            btn.disabled = false; btn.textContent = "Create Bond"; return;
          }
        }
        steps.push({ label: "Approve WXDAI for vault", action: "approveWxdai" });
        steps.push({ label: "Deposit to USD Savings", action: "depositSdai" });
      }
    } else {
      // Non-Gnosis or non-sDAI: just check balance directly
      const tokenBal = await getBalance(tokenAddr);
      if (tokenBal < bondAmount) {
        const need = ethers.formatUnits(bondAmount - tokenBal, decimals);
        showMsg(msg, `Insufficient ${friendlyTokenName(tokenAddr, '')} balance. Need ${parseFloat(need).toLocaleString(undefined, {maximumFractionDigits: 2})} more.`, "error");
        btn.disabled = false; btn.textContent = "Create Bond"; return;
      }
    }

    // Check if token needs approval for the bond contract
    const currentAllowance = await tokenContract.allowance(userAddr, chain().contract);
    if (currentAllowance < bondAmount) {
      steps.push({ label: `Approve ${friendlyTokenName(tokenAddr, '')}`, action: "approveToken" });
    }

    steps.push({ label: "Create Bond", action: "createBond" });

    // Render stepper
    renderTxStepper(stepperEl, steps.map(s => s.label));
    let stepIdx = 0;

    // Execute steps
    for (const step of steps) {
      updateStepStatus(stepperEl, stepIdx, 'active');

      if (step.action === "wrapXdai") {
        await wrapXdaiToWxdai(step.amount);
      } else if (step.action === "approveWxdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await ensureApproval(WXDAI_ADDRESS, wxdaiBal2, SDAI_ADDRESS);
      } else if (step.action === "depositSdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await wrapWxdaiToSdai(wxdaiBal2);
      } else if (step.action === "approveToken") {
        // Re-read balance after potential wrapping
        const bal = await getBalance(tokenAddr);
        const approveAmt = bal > bondAmount ? bondAmount : bal;
        await ensureApproval(tokenAddr, approveAmt, chain().contract);
      } else if (step.action === "createBond") {
        const metadata = document.getElementById("bondMetadata").value.trim();
        const tx = await bondContract.createBond(tokenAddr, bondAmount, challengeAmount, judgeFee, judgeAddr, deadline, acceptanceDelay, rulingBuffer, metadata);
        const receipt = await waitForTx(tx);
        const iface = new ethers.Interface(BOND_ABI);
        let bondId = null;
        for (const log of receipt.logs) {
          try {
            const parsed = iface.parseLog({ topics: log.topics, data: log.data });
            if (parsed && parsed.name === "BondCreated") { bondId = parsed.args.bondId; break; }
          } catch (_) {}
        }

        updateStepStatus(stepperEl, stepIdx, 'done');

        // Show success prominently — hide form fields, show success card in msg
        document.querySelectorAll('#createForm .form-group, #createForm .mode-toggle, #createBtn, #createStepper').forEach(el => el.style.display = 'none');
        if (bondId !== null) {
          msg.innerHTML = `<div class="success-card">
            <div class="sc-label">Bond created!</div>
            <div class="sc-id">Bond #${bondId}</div>
            <div class="sc-actions">
              <button class="success" onclick="viewBondById(${bondId})">View Bond</button>
              <button class="secondary" onclick="copyBondLink(${bondId})">Copy Link</button>
              <button class="secondary" onclick="window.location.reload()">Create Another</button>
            </div>
          </div>`;
        } else {
          msg.innerHTML = `<div class="success-card">
            <div class="sc-label">Bond created!</div>
            <div class="sc-id">Check tx for ID</div>
            <div class="sc-actions">
              <button class="secondary" onclick="window.location.reload()">Create Another</button>
            </div>
          </div>`;
        }
        msg.scrollIntoView({ behavior: 'smooth', block: 'start' });

        tokenCache = {};
        myBondsLoaded = false;
        browseBondsLoaded = false;
        refreshAllBalances();
        return; // Done
      }

      updateStepStatus(stepperEl, stepIdx, 'done');
      stepIdx++;
    }
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  } finally {
    btn.disabled = false;
    btn.textContent = "Create Bond";
  }
}

// ─── Tabs ─────────────────────────────────────────────────────────────
function switchTab(name) {
  document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.tab === name));
  ["create", "browse", "judges", "my", "view"].forEach(t => {
    const el = document.getElementById("tab-" + t);
    if (el) el.classList.toggle("hidden", t !== name);
  });
  if (name === "my" && userAddr) loadMyBonds();
  if (name === "browse") loadBrowseBonds();
  if (name === "judges") loadJudges();
}

// ─── Load Bond ────────────────────────────────────────────────────────
async function loadBond() {
  const idStr = document.getElementById("bondIdInput").value.trim();
  if (idStr === "") return;
  const bondId = parseInt(idStr);
  const msg = document.getElementById("viewMsg");

  // Hide previous bond display and clear messages
  document.getElementById("bondDisplay").classList.add("hidden");
  document.getElementById("bondActions").classList.add("hidden");
  msg.innerHTML = "";

  try {
    const readProvider = new ethers.JsonRpcProvider(chain().rpc);
    const readContract = new ethers.Contract(chain().contract, BOND_ABI, readProvider);

    const nextId = await readContract.nextBondId();
    if (BigInt(bondId) >= nextId) {
      if (nextId === 0n) {
        showMsg(msg, `No bonds exist on ${chain().name} yet. Be the first to create one!`, "error");
      } else {
        showMsg(msg, `Bond #${bondId} does not exist on ${chain().name}. Latest bond is #${Number(nextId) - 1}.`, "error");
      }
      return;
    }

    const b = await readContract.bonds(bondId);
    const [poster, judge, token, bondAmount, challengeAmount, judgeFee, deadline, acceptanceDelay, rulingBuffer, metadata, settled, conceded, currentChallenge, lastChallengeTime] = b;

    const tokenContract = new ethers.Contract(token, ERC20_ABI, readProvider);
    let decimals = 18, symbol = "???";
    try { decimals = Number(await tokenContract.decimals()); } catch (_) {}
    try { symbol = await tokenContract.symbol(); } catch (_) {}

    const now = BigInt(Math.floor(Date.now() / 1000));
    const challengeCount = Number(await readContract.getChallengeCount(bondId));
    const currentIdx = Number(currentChallenge);

    // Get ruling window from contract
    let rwStart = 0n, rwEnd = 0n;
    try {
      rwStart = await readContract.rulingWindowStart(bondId);
      rwEnd = await readContract.rulingDeadline(bondId);
    } catch (_) {
      // Fallback: compute locally
      const afterDeadline = deadline;
      const afterAcceptance = lastChallengeTime + acceptanceDelay;
      rwStart = afterDeadline > afterAcceptance ? afterDeadline : afterAcceptance;
      rwEnd = rwStart + rulingBuffer;
    }

    // Determine status
    let status, statusClass;
    if (conceded) {
      status = "Conceded"; statusClass = "status-conceded";
    } else if (settled) {
      const filter1 = readContract.filters.RuledForChallenger(bondId);
      const filter2 = readContract.filters.BondWithdrawn(bondId);
      const filter3 = readContract.filters.BondTimedOut(bondId);
      const filter4 = readContract.filters.BondRejectedByJudge(bondId);
      const [evC, evW, evT, evR] = await Promise.all([
        readContract.queryFilter(filter1, chain().deployBlock).catch(() => []),
        readContract.queryFilter(filter2, chain().deployBlock).catch(() => []),
        readContract.queryFilter(filter3, chain().deployBlock).catch(() => []),
        readContract.queryFilter(filter4, chain().deployBlock).catch(() => []),
      ]);
      if (evR.length > 0) { status = "Rejected by Judge"; statusClass = "status-timedout"; }
      else if (evC.length > 0) { status = "Challenger Won"; statusClass = "status-forfeited"; }
      else if (evW.length > 0) { status = "Withdrawn"; statusClass = "status-withdrawn"; }
      else if (evT.length > 0) { status = "Timed Out"; statusClass = "status-timedout"; }
      else { status = "Settled"; statusClass = "status-settled"; }
    } else if (now > rwEnd && currentIdx < challengeCount) {
      status = "Timeout (claimable)"; statusClass = "status-expired";
    } else if (now >= rwStart && currentIdx < challengeCount) {
      status = "Ruling Period"; statusClass = "status-active";
    } else if (now > deadline && currentIdx >= challengeCount) {
      status = "Withdrawable"; statusClass = "status-expired";
    } else if (currentIdx < challengeCount && now < rwStart) {
      status = "Acceptance Period"; statusClass = "status-pending";
    } else {
      status = "Active"; statusClass = "status-active";
    }

    currentViewBondId = bondId;
    currentViewBondData = { poster, judge, token, bondAmount, challengeAmount, judgeFee, deadline, acceptanceDelay, rulingBuffer, metadata, settled, conceded, currentChallenge, lastChallengeTime, decimals, symbol, challengeCount, currentIdx, status, rwStart, rwEnd };

    document.getElementById("bondDisplay").classList.remove("hidden");
    document.getElementById("bId").textContent = bondId;
    document.getElementById("bStatus").innerHTML = `<span class="status-badge ${statusClass}">${status}</span>`;
    setAddrLink("bPoster", poster);
    setAddrLink("bJudge", judge);
    const tokenDisplayName = friendlyTokenName(token, symbol);
    setAddrLink("bToken", token, tokenDisplayName);

    // Convert sDAI shares to USD value for display
    let displayBondAmt = bondAmount, displayChallengeAmt = challengeAmount, displayJudgeFee = judgeFee;
    let displayDecimals = decimals;
    const isSdaiToken = token.toLowerCase() === SDAI_ADDRESS.toLowerCase();
    if (isSdaiToken) {
      try {
        const sdaiVault = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, readProvider);
        displayBondAmt = await sdaiVault.convertToAssets(bondAmount);
        displayChallengeAmt = await sdaiVault.convertToAssets(challengeAmount);
        displayJudgeFee = await sdaiVault.convertToAssets(judgeFee);
      } catch (_) {} // fallback to raw shares
    }
    const fmtBondAmt = parseFloat(ethers.formatUnits(displayBondAmt, displayDecimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
    const fmtChallengeAmt = parseFloat(ethers.formatUnits(displayChallengeAmt, displayDecimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
    const fmtJudgeFee = parseFloat(ethers.formatUnits(displayJudgeFee, displayDecimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
    document.getElementById("bBondAmount").textContent = `$${fmtBondAmt}`;
    document.getElementById("bChallengeAmount").textContent = `$${fmtChallengeAmt}`;
    document.getElementById("bJudgeFee").textContent = `$${fmtJudgeFee}`;
    document.getElementById("bDeadline").textContent = new Date(Number(deadline) * 1000).toLocaleString();
    const delayDays = Number(acceptanceDelay) / 86400;
    document.getElementById("bAcceptanceDelay").textContent = delayDays >= 1 ? `${delayDays} day${delayDays !== 1 ? 's' : ''}` : `${Number(acceptanceDelay) / 3600} hours`;
    if (challengeCount > 0 && Number(rwStart) > 0) {
      document.getElementById("bRulingStart").textContent = new Date(Number(rwStart) * 1000).toLocaleString();
      document.getElementById("bRulingDeadline").textContent = new Date(Number(rwEnd) * 1000).toLocaleString();
    } else {
      document.getElementById("bRulingStart").textContent = "After first challenge";
      document.getElementById("bRulingDeadline").textContent = "After first challenge";
    }

    const metaRow = document.getElementById("bMetadataRow");
    const metaEl = document.getElementById("bMetadata");
    if (metadata) {
      metaEl.textContent = metadata;
      metaRow.style.display = "";
    } else {
      metaRow.style.display = "none";
    }

    // ─── Belief Thresholds ────────────────────────────────────────
    const beliefCard = document.getElementById("beliefCard");
    const netPot = bondAmount + challengeAmount - judgeFee;
    if (netPot > 0n) {
      const challengerPct = (Number(challengeAmount) * 100 / Number(netPot)).toFixed(1);
      const posterPct = ((1 - Number(bondAmount) / Number(netPot)) * 100).toFixed(1);
      document.getElementById("beliefChallenger").textContent = `>${challengerPct}%`;
      document.getElementById("beliefPoster").textContent = `<${posterPct}%`;
      beliefCard.classList.remove("hidden");
    } else {
      beliefCard.classList.add("hidden");
    }

    // ─── Concession Display ──────────────────────────────────────
    const concessionCard = document.getElementById("concessionCard");
    if (conceded) {
      // Fetch concession metadata from event
      try {
        const concedeFilter = readContract.filters.ClaimConceded(bondId);
        const concedeEvents = await readContract.queryFilter(concedeFilter, chain().deployBlock).catch(() => []);
        if (concedeEvents.length > 0) {
          const concedeMeta = concedeEvents[0].args.metadata || concedeEvents[0].args[2] || "";
          document.getElementById("concessionText").textContent = concedeMeta || "The poster conceded this claim.";
        } else {
          document.getElementById("concessionText").textContent = "The poster conceded this claim.";
        }
      } catch (_) {
        document.getElementById("concessionText").textContent = "The poster conceded this claim.";
      }
      concessionCard.classList.remove("hidden");
    } else {
      concessionCard.classList.add("hidden");
    }

    const url = new URL(window.location);
    const chainParamEntry = Object.entries({gnosis: 100, polygon: 137, ethereum: 1}).find(([,v]) => v === activeChainId);
    if (chainParamEntry) url.searchParams.set("chain", chainParamEntry[0]);
    url.searchParams.set("bond", bondId);
    history.replaceState(null, "", url);

    // ─── Risk/Reward Card ────────────────────────────────────────
    const rrCard = document.getElementById("riskRewardCard");
    if (!settled && !conceded && now <= deadline) {
      const netProfit = displayBondAmt - displayJudgeFee;
      const netProfitFmt = parseFloat(ethers.formatUnits(netProfit, displayDecimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const riskFmt = fmtChallengeAmt;
      const displayNetPot = displayBondAmt + displayChallengeAmt - displayJudgeFee;
      const challengerBeliefPct = displayNetPot > 0n ? (Number(displayChallengeAmt) * 100 / Number(displayNetPot)).toFixed(0) : "?";

      document.getElementById("rrWinAmount").textContent = `+$${netProfitFmt}`;
      document.getElementById("rrRiskAmount").textContent = `$${riskFmt}`;
      document.getElementById("rrNote").textContent = `By challenging, you signal >${challengerBeliefPct}% belief the poster is wrong. If you lose, you forfeit your $${riskFmt} deposit.`;
      document.getElementById("challengeStepper").innerHTML = "";
      document.getElementById("challengeMsg").innerHTML = "";
      document.getElementById("challengeMetadata").value = "";
      rrCard.classList.remove("hidden");
    } else {
      rrCard.classList.add("hidden");
    }

    // ─── Challenge Queue ────────────────────────────────────────
    const queueSection = document.getElementById("challengeQueueSection");
    const challengeList = document.getElementById("challengeList");
    challengeList.innerHTML = "";

    if (challengeCount > 0) {
      queueSection.classList.remove("hidden");
      const statusLabels = ["Pending", "Won", "Lost", "Refunded"];
      const statusClasses = ["status-pending", "status-won", "status-lost", "status-refunded"];

      for (let i = 0; i < challengeCount; i++) {
        const [cAddr, cStatus, cMeta] = await readContract.getChallenge(bondId, i);
        const isCurrent = (i === currentIdx && !settled && !conceded);
        const item = document.createElement("div");
        item.className = "challenge-item" + (isCurrent ? " current" : "");
        item.innerHTML = `
          <div>
            <span class="ci-idx">#${i}</span>
            <span class="ci-addr">${short(cAddr)}</span>
            ${isCurrent ? ' <span style="color:var(--accent);font-size:11px;">(current)</span>' : ''}
            ${cMeta ? `<div class="ci-meta" title="${escapeHtml(cMeta)}">${escapeHtml(cMeta)}</div>` : ''}
          </div>
          <span class="status-badge ${statusClasses[cStatus]}">${statusLabels[cStatus]}</span>`;
        challengeList.appendChild(item);
      }
    } else {
      queueSection.classList.add("hidden");
    }

    // ─── Action Buttons ─────────────────────────────────────────
    const actionsDiv = document.getElementById("bondActions");
    const btnsDiv = document.getElementById("actionBtns");
    btnsDiv.innerHTML = "";

    if (!settled && !conceded && signer) {
      const ua = userAddr.toLowerCase();
      const hasPendingChallenge = currentIdx < challengeCount;
      const inRulingWindow = now >= rwStart && now <= rwEnd;

      // Poster concede (only before any ruling)
      if (ua === poster.toLowerCase() && hasPendingChallenge && currentIdx === 0) {
        const concedeBtn = document.createElement("button");
        concedeBtn.className = "concede";
        concedeBtn.textContent = "Concede Claim";
        concedeBtn.onclick = () => doConcede(bondId);
        btnsDiv.appendChild(concedeBtn);
      }

      // Judge actions on current challenge (only in ruling window)
      if (ua === judge.toLowerCase() && hasPendingChallenge && inRulingWindow) {
        // Fee waiver input
        const feeGroup = document.createElement("div");
        feeGroup.className = "fee-waiver-group";
        feeGroup.innerHTML = `<label>Judge fee to charge: </label><input type="text" id="feeChargedInput" value="${parseFloat(ethers.formatUnits(judgeFee, decimals)).toFixed(2)}" style="max-width:100px;display:inline-block;padding:6px 10px;font-size:13px;"> <span style="font-size:12px;color:var(--muted);">max: $${fmtJudgeFee} (enter 0 to waive)</span>`;
        btnsDiv.parentNode.insertBefore(feeGroup, btnsDiv);

        const ruleForCBtn = document.createElement("button");
        ruleForCBtn.className = "danger";
        ruleForCBtn.textContent = "Rule for Challenger";
        ruleForCBtn.onclick = () => doRuleForChallenger(bondId, decimals, judgeFee);
        btnsDiv.appendChild(ruleForCBtn);

        const ruleForPBtn = document.createElement("button");
        ruleForPBtn.className = "success";
        ruleForPBtn.textContent = "Rule for Poster";
        ruleForPBtn.onclick = () => doRuleForPoster(bondId, decimals, judgeFee);
        btnsDiv.appendChild(ruleForPBtn);
      }

      // Poster withdraw (no pending challenges)
      if (ua === poster.toLowerCase() && !hasPendingChallenge) {
        const wdBtn = document.createElement("button");
        wdBtn.className = "success";
        wdBtn.textContent = "Withdraw Bond";
        wdBtn.onclick = () => doWithdrawBond(bondId);
        btnsDiv.appendChild(wdBtn);
      }

      // Judge reject bond (anytime bond isn't settled)
      if (ua === judge.toLowerCase()) {
        const rejectBtn = document.createElement("button");
        rejectBtn.className = "reject";
        rejectBtn.textContent = "Reject Bond";
        rejectBtn.title = "Reject — all parties refunded, no fee charged";
        rejectBtn.onclick = () => doRejectBond(bondId);
        btnsDiv.appendChild(rejectBtn);
      }

      // Timeout claim
      if (now > rwEnd && hasPendingChallenge) {
        const toBtn = document.createElement("button");
        toBtn.className = "secondary";
        toBtn.textContent = "Claim Timeout (Refund All)";
        toBtn.onclick = () => doClaimTimeout(bondId);
        btnsDiv.appendChild(toBtn);
      }

      actionsDiv.classList.toggle("hidden", btnsDiv.children.length === 0);
    } else {
      actionsDiv.classList.add("hidden");
    }
    msg.innerHTML = "";
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  }
}

// ─── Smart Challenge (with stepper) ──────────────────────────────────
async function smartChallengeBond() {
  if (!currentViewBondId && currentViewBondId !== 0) return;
  const bondId = currentViewBondId;
  const btn = document.getElementById("challengeBtn");
  const msg = document.getElementById("challengeMsg");
  const stepperEl = document.getElementById("challengeStepper");

  if (!signer) {
    showMsg(msg, "Sign in first to challenge this bond.", "error");
    return;
  }

  try {
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Checking...';

    const readContract = new ethers.Contract(chain().contract, BOND_ABI, signer);
    const b = await readContract.bonds(bondId);
    const tokenAddr = b[2];
    const challengeAmount = b[4];
    const challengeCount = Number(await readContract.getChallengeCount(bondId));

    // Check if user already challenged this bond
    let userAlreadyChallenged = false;
    for (let i = 0; i < challengeCount; i++) {
      const ch = await readContract.getChallenge(bondId, i);
      if (ch[0].toLowerCase() === userAddr.toLowerCase()) { userAlreadyChallenged = true; break; }
    }

    if (userAlreadyChallenged) {
      btn.disabled = false; btn.textContent = "Challenge This Bond";
      const proceed = confirm(
        "⚠️ You have already challenged this bond!\n\n" +
        "Submitting another challenge will:\n" +
        "• Lock an additional deposit of the challenge amount\n" +
        "• Join the back of the challenge queue\n" +
        "• Each challenge is resolved independently — you could lose both deposits\n\n" +
        "Are you sure you want to challenge again?"
      );
      if (!proceed) return;
    } else if (challengeCount > 0) {
      btn.disabled = false; btn.textContent = "Challenge This Bond";
      const proceed = confirm(
        `This bond already has ${challengeCount} challenge${challengeCount > 1 ? 's' : ''} in the queue.\n\n` +
        "Your challenge will:\n" +
        "• Join the back of the queue (position #" + challengeCount + ")\n" +
        "• Lock your deposit until the judge resolves your challenge\n" +
        "• Earlier challenges are resolved first — yours may take longer\n\n" +
        "Continue?"
      );
      if (!proceed) return;
    }

    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Processing...';

    const isSdai = needsWrapping(tokenAddr);
    const steps = [];

    // Check if user has enough of the challenge token
    const tokenBal = await getBalance(tokenAddr);

    if (tokenBal < challengeAmount && isSdai) {
      // Try wrapping (Gnosis only)
      const wxdaiBal = await getBalance(WXDAI_ADDRESS);
      const nativeBal = await (provider || new ethers.JsonRpcProvider(chain().rpc)).getBalance(userAddr);
      const sdaiDeficit = challengeAmount - tokenBal;
      const wxdaiNeeded = sdaiDeficit + (sdaiDeficit / 1000n);

      if (wxdaiBal < wxdaiNeeded) {
        const wxdaiDeficit = wxdaiNeeded - wxdaiBal;
        const gasReserve = ethers.parseEther("0.01");
        if (nativeBal > gasReserve + wxdaiDeficit) {
          steps.push({ label: "Wrap xDAI to WXDAI", action: "wrapXdai", amount: wxdaiDeficit });
        } else {
          showMsg(msg, "Insufficient funds to challenge. Get more USD first.", "error");
          showFundingOptions(msg);
          btn.disabled = false; btn.textContent = "Challenge This Bond"; return;
        }
      }
      steps.push({ label: "Approve WXDAI for vault", action: "approveWxdai" });
      steps.push({ label: "Deposit to USD Savings", action: "depositSdai", amount: wxdaiNeeded });
    } else if (tokenBal < challengeAmount) {
      showMsg(msg, "Insufficient token balance to challenge.", "error");
      btn.disabled = false; btn.textContent = "Challenge This Bond"; return;
    }

    // Approve + Challenge
    const tokenContract = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
    const currentAllowance = await tokenContract.allowance(userAddr, chain().contract);
    if (currentAllowance < challengeAmount) {
      steps.push({ label: "Approve currency", action: "approveToken" });
    }
    steps.push({ label: "Submit Challenge", action: "challenge" });

    renderTxStepper(stepperEl, steps.map(s => s.label));
    let stepIdx = 0;

    for (const step of steps) {
      updateStepStatus(stepperEl, stepIdx, 'active');

      if (step.action === "wrapXdai") {
        await wrapXdaiToWxdai(step.amount);
      } else if (step.action === "approveWxdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await ensureApproval(WXDAI_ADDRESS, wxdaiBal2, SDAI_ADDRESS);
      } else if (step.action === "depositSdai") {
        const wxdaiBal2 = await getBalance(WXDAI_ADDRESS);
        await wrapWxdaiToSdai(wxdaiBal2);
      } else if (step.action === "approveToken") {
        await ensureApproval(tokenAddr, challengeAmount, chain().contract);
      } else if (step.action === "challenge") {
        const challengeMeta = document.getElementById("challengeMetadata").value.trim();
        const tx = await bondContract.challenge(bondId, challengeMeta);
        await waitForTx(tx);
      }

      updateStepStatus(stepperEl, stepIdx, 'done');
      stepIdx++;
    }

    showMsg(msg, "Challenge submitted!", "success");
    loadBond();
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  } finally {
    btn.disabled = false;
    btn.textContent = "Challenge This Bond";
  }
}

function showFundingOptions(msgEl) {
  const fundingHtml = `<div style="margin-top:8px;">
    <button onclick="openFundingGuide()" style="font-size:12px;padding:6px 12px;">How to Get Funds</button>
    <button class="copy-addr-btn" onclick="copyAddress()" style="margin-left:6px;">Copy Wallet Address</button>
  </div>`;
  msgEl.innerHTML += fundingHtml;
}

// ─── Bond actions ─────────────────────────────────────────────────────
async function doConcede(bondId) {
  const msg = document.getElementById("viewMsg");
  const concedeMeta = prompt("Why are you conceding? (stored on-chain)") || "";
  if (concedeMeta === null) return; // user cancelled
  try {
    showMsg(msg, "Processing concession...", "info");
    const tx = await bondContract.concede(bondId, concedeMeta);
    await waitForTx(tx);
    showMsg(msg, "Claim conceded. Everyone has been refunded.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

function _parseFeeCharged(decimals, maxFee) {
  const input = document.getElementById("feeChargedInput");
  const val = input ? input.value.trim() : "";
  if (!val || isNaN(val)) return maxFee; // default to max fee
  const parsed = ethers.parseUnits(val, decimals);
  if (parsed > maxFee) return maxFee;
  return parsed;
}

async function doRuleForChallenger(bondId, decimals, maxFee) {
  const msg = document.getElementById("viewMsg");
  try {
    const feeCharged = _parseFeeCharged(decimals, maxFee);
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.ruleForChallenger(bondId, feeCharged);
    await waitForTx(tx);
    showMsg(msg, "Ruled for challenger. Bond settled.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

async function doRuleForPoster(bondId, decimals, maxFee) {
  const msg = document.getElementById("viewMsg");
  try {
    const feeCharged = _parseFeeCharged(decimals, maxFee);
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.ruleForPoster(bondId, feeCharged);
    await waitForTx(tx);
    showMsg(msg, "Ruled for poster. Queue advanced.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

async function doWithdrawBond(bondId) {
  const msg = document.getElementById("viewMsg");
  try {
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.withdrawBond(bondId);
    await waitForTx(tx);
    showMsg(msg, "Bond withdrawn.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

async function doClaimTimeout(bondId) {
  const msg = document.getElementById("viewMsg");
  try {
    showMsg(msg, "Processing... this takes about 5 seconds", "info");
    const tx = await bondContract.claimTimeout(bondId);
    await waitForTx(tx);
    showMsg(msg, "Timeout claimed. All refunded.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

// ─── Browse All Bonds ─────────────────────────────────────────────────
async function loadBrowseBonds() {
  if (browseBondsLoaded) return;

  const listEl = document.getElementById("browseBondsList");
  const loadingEl = document.getElementById("browseLoading");
  const emptyEl = document.getElementById("browseEmpty");
  document.getElementById("browseChainNote").textContent = `Showing bonds on ${chain().name}. Switch chains to see bonds on other networks.`;

  loadingEl.classList.remove("hidden");
  listEl.innerHTML = "";
  emptyEl.classList.add("hidden");

  try {
    const readProvider = new ethers.JsonRpcProvider(chain().rpc);
    const readContract = new ethers.Contract(chain().contract, BOND_ABI, readProvider);

    const filter = readContract.filters.BondCreated();
    const events = await readContract.queryFilter(filter, chain().deployBlock).catch(() => []);

    const now = BigInt(Math.floor(Date.now() / 1000));
    const allBonds = [];

    // Fetch sDAI rate once for USD conversion
    let sdaiRate = null; // assets per 1 share (1e18)
    if (activeChainId === 100) {
      try {
        const sdaiVault = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, readProvider);
        sdaiRate = await sdaiVault.convertToAssets(ethers.parseUnits('1', 18));
      } catch (_) {}
    }

    for (const ev of events) {
      const bondId = Number(ev.args.bondId);
      try {
        const b = await readContract.bonds(bondId);
        const [, , token, bondAmount, challengeAmount, , deadline, , , metadata, settled, conceded, , lastChallengeTime] = b;

        let symbol = "???", decimals = 18;
        try {
          const tc = new ethers.Contract(token, ERC20_ABI, readProvider);
          [symbol, decimals] = await Promise.all([tc.symbol(), tc.decimals().then(Number)]);
        } catch (_) {}

        // Determine status
        let status, statusClass;
        if (conceded) { status = "Conceded"; statusClass = "status-conceded"; }
        else if (settled) { status = "Settled"; statusClass = "status-settled"; }
        else if (now > deadline) { status = "Expired"; statusClass = "status-expired"; }
        else { status = "Active"; statusClass = "status-active"; }

        // Sort key: most recent activity (challenge time or block timestamp)
        const lastActivity = lastChallengeTime > 0n ? Number(lastChallengeTime) : Number(ev.blockNumber);

        allBonds.push({ bondId, token, bondAmount, challengeAmount, deadline, metadata, symbol, decimals, status, statusClass, lastActivity, settled, conceded });
      } catch (_) {}
    }

    loadingEl.classList.add("hidden");

    if (allBonds.length === 0) {
      emptyEl.classList.remove("hidden");
      browseBondsLoaded = true;
      return;
    }

    // Sort: active bonds first, then by most recent activity
    allBonds.sort((a, b) => {
      const aActive = a.status === "Active" ? 1 : 0;
      const bActive = b.status === "Active" ? 1 : 0;
      if (aActive !== bActive) return bActive - aActive;
      return b.lastActivity - a.lastActivity;
    });

    for (const bond of allBonds) {
      let dispBond = bond.bondAmount, dispChallenge = bond.challengeAmount;
      if (sdaiRate && bond.token.toLowerCase() === SDAI_ADDRESS.toLowerCase()) {
        dispBond = bond.bondAmount * sdaiRate / ethers.parseUnits('1', 18);
        dispChallenge = bond.challengeAmount * sdaiRate / ethers.parseUnits('1', 18);
      }
      const bondAmt = parseFloat(ethers.formatUnits(dispBond, bond.decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const challengeAmt = parseFloat(ethers.formatUnits(dispChallenge, bond.decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const desc = bond.metadata || "No description";
      const isActive = bond.status === "Active";
      const deadlineInfo = isActive ? `Deadline: <span class="countdown">${formatCountdown(Number(bond.deadline))}</span>` : `<span class="status-badge ${bond.statusClass}" style="font-size:10px;">${bond.status}</span>`;

      const card = document.createElement("div");
      card.className = "bond-browse-item";
      if (!isActive) card.style.opacity = "0.7";
      card.onclick = () => viewBondById(bond.bondId);
      card.innerHTML = `
        <div class="bb-desc">${escapeHtml(desc)}</div>
        <div class="bond-browse-stats">
          <span>Bond: <span class="stat-val">$${bondAmt}</span></span>
          <span>Challenge: <span class="stat-val">$${challengeAmt}</span></span>
          <span>${deadlineInfo}</span>
        </div>`;
      listEl.appendChild(card);
    }

    browseBondsLoaded = true;
  } catch (err) {
    loadingEl.classList.add("hidden");
    listEl.innerHTML = `<div class="msg msg-error">Error loading bonds: ${err.message}</div>`;
  }
}

function formatCountdown(unixTimestamp) {
  const now = Math.floor(Date.now() / 1000);
  const diff = unixTimestamp - now;
  if (diff <= 0) return "Expired";
  const days = Math.floor(diff / 86400);
  const hours = Math.floor((diff % 86400) / 3600);
  if (days > 30) return `${Math.floor(days / 30)} months`;
  if (days > 0) return `${days}d ${hours}h`;
  const mins = Math.floor((diff % 3600) / 60);
  return `${hours}h ${mins}m`;
}

// ─── Helpers ──────────────────────────────────────────────────────────
function setDeadline(days) {
  const d = new Date(Date.now() + days * 86400000);
  document.getElementById("deadline").value = d.toISOString().slice(0, 10);
  document.querySelectorAll(".preset:not(.ruling-preset)").forEach(b => b.classList.toggle("active", b.dataset.days == days));
}

function setRulingBuffer(days) {
  rulingBufferDays = days;
  document.querySelectorAll(".ruling-preset").forEach(b => b.classList.toggle("active", b.dataset.buffer == days));
}

function setAcceptanceDelay(days) {
  acceptanceDelayDays = days;
  document.querySelectorAll(".acceptance-preset").forEach(b => b.classList.toggle("active", b.dataset.adelay == days));
}

function short(addr) { return addr.slice(0, 6) + "..." + addr.slice(-4); }

// ─── ENS Resolution (always via Ethereum mainnet) ─────────────────────
const ensCache = {};
const ensProvider = new ethers.JsonRpcProvider("https://eth.llamarpc.com");

async function resolveEns(addr) {
  const key = addr.toLowerCase();
  if (key in ensCache) return ensCache[key];
  ensCache[key] = null; // mark as in-flight
  try {
    const name = await ensProvider.lookupAddress(addr);
    ensCache[key] = name;
    return name;
  } catch (_) {
    ensCache[key] = null;
    return null;
  }
}

let judgeEnsTimer = null;
function resolveJudgeEns() {
  clearTimeout(judgeEnsTimer);
  judgeEnsTimer = setTimeout(async () => {
    const input = document.getElementById("judgeAddr");
    const hint = document.getElementById("judgeEnsHint");
    const val = input.value.trim();
    if (val.endsWith('.eth') || val.endsWith('.xyz') || val.endsWith('.id')) {
      hint.textContent = 'Resolving ENS name...';
      hint.style.color = 'var(--muted)';
      try {
        const addr = await ensProvider.resolveName(val);
        if (addr) {
          hint.innerHTML = `Resolved: <b>${short(addr)}</b>`;
          hint.style.color = 'var(--green)';
          input.dataset.resolvedAddr = addr;
        } else {
          hint.textContent = 'ENS name not found.';
          hint.style.color = 'var(--red)';
          delete input.dataset.resolvedAddr;
        }
      } catch (_) {
        hint.textContent = 'Could not resolve ENS name.';
        hint.style.color = 'var(--red)';
        delete input.dataset.resolvedAddr;
      }
    } else {
      hint.textContent = 'The judge rules on challenges. Pick someone both parties trust.';
      hint.style.color = 'var(--muted)';
      delete input.dataset.resolvedAddr;
    }
  }, 500);
}

function setAddrLink(elId, addr, label) {
  const el = document.getElementById(elId);
  el.href = chain().explorer + "/address/" + addr;
  el.textContent = label ? `${label} (${short(addr)})` : short(addr);
  // Async ENS lookup — update text when resolved
  if (!label) {
    resolveEns(addr).then(name => {
      if (name) el.textContent = `${name} (${short(addr)})`;
    });
  }
}

function showMsg(el, html, type) {
  el.innerHTML = `<div class="msg msg-${type}">${html}</div>`;
}

function viewBondById(id) {
  document.getElementById("bondIdInput").value = id;
  switchTab("view");
  loadBond();
}

function copyBondLink(id) {
  const chainParam = Object.entries({gnosis: 100, polygon: 137, ethereum: 1}).find(([,v]) => v === activeChainId);
  const chainStr = chainParam ? chainParam[0] : "gnosis";
  const url = `${window.location.origin}${window.location.pathname}?chain=${chainStr}&bond=${id}`;
  navigator.clipboard.writeText(url).then(() => {
    const btn = event.target;
    btn.textContent = "Copied!";
    setTimeout(() => { btn.textContent = "Copy Link"; }, 1500);
  }).catch(() => { prompt("Copy this link:", url); });
}

function escapeHtml(str) {
  const d = document.createElement("div");
  d.textContent = str;
  return d.innerHTML;
}

async function refreshAllBalances() {
  if (!userAddr || !signer) return;
  const tokens = getAllTokens();
  const promises = tokens.map(async (t) => {
    try {
      const token = new ethers.Contract(t.address, ERC20_ABI, signer);
      const [balance, allowance, decimals, symbol] = await Promise.all([
        token.balanceOf(userAddr),
        token.allowance(userAddr, chain().contract),
        token.decimals(),
        token.symbol(),
      ]);
      tokenCache[t.address.toLowerCase()] = { symbol, decimals: Number(decimals), balance, allowance };
    } catch (_) {}
  });
  await Promise.all(promises);
  buildTokenSelect();
  const sel = document.getElementById("tokenSelect");
  if (sel && !sel.value) sel.value = chain().defaultToken.address;
  updateBalanceDisplay(getSelectedToken());
}

// ─── My Bonds ─────────────────────────────────────────────────────────
async function loadMyBonds() {
  if (!userAddr) return;
  const listEl = document.getElementById("myBondsList");
  const loadingEl = document.getElementById("myBondsLoading");
  const emptyEl = document.getElementById("myBondsEmpty");
  const contentEl = document.getElementById("myBondsContent");
  const connectEl = document.getElementById("myBondsConnect");

  connectEl.classList.add("hidden");
  contentEl.classList.remove("hidden");

  if (myBondsLoaded) return;

  loadingEl.classList.remove("hidden");
  listEl.innerHTML = "";
  emptyEl.classList.add("hidden");

  try {
    const readProvider = new ethers.JsonRpcProvider(chain().rpc);
    const readContract = new ethers.Contract(chain().contract, BOND_ABI, readProvider);

    // Fetch sDAI rate once for USD conversion
    let myBondsSdaiRate = null;
    if (activeChainId === 100) {
      try {
        const sdaiVault = new ethers.Contract(SDAI_ADDRESS, SDAI_ABI, readProvider);
        myBondsSdaiRate = await sdaiVault.convertToAssets(ethers.parseUnits('1', 18));
      } catch (_) {}
    }

    const posterFilter = readContract.filters.BondCreated(null, userAddr);
    const judgeFilter = readContract.filters.BondCreated(null, null, userAddr);
    const challengerFilter = readContract.filters.Challenged(null, null, userAddr);

    const [posterEvents, judgeEvents, challengerEvents] = await Promise.all([
      readContract.queryFilter(posterFilter, chain().deployBlock).catch(() => []),
      readContract.queryFilter(judgeFilter, chain().deployBlock).catch(() => []),
      readContract.queryFilter(challengerFilter, chain().deployBlock).catch(() => []),
    ]);

    const seen = new Set();
    const allBondIds = [];
    for (const ev of [...posterEvents, ...judgeEvents]) {
      const id = Number(ev.args.bondId);
      if (!seen.has(id)) { seen.add(id); allBondIds.push(id); }
    }
    for (const ev of challengerEvents) {
      const id = Number(ev.args.bondId);
      if (!seen.has(id)) { seen.add(id); allBondIds.push(id); }
    }

    allBondIds.sort((a, b) => b - a);
    loadingEl.classList.add("hidden");

    if (allBondIds.length === 0) {
      emptyEl.classList.remove("hidden");
      myBondsLoaded = true;
      return;
    }

    for (const id of allBondIds) {
      const b = await readContract.bonds(id);
      const [poster, judge, token, bondAmount, challengeAmount, judgeFee, deadline, acceptanceDelay, rulingBuffer, metadata, settled, conceded, currentChallenge, lastChallengeTime] = b;

      let symbol = "???", decimals = 18;
      const tokenContract = new ethers.Contract(token, ERC20_ABI, readProvider);
      try { symbol = await tokenContract.symbol(); } catch (_) {}
      try { decimals = Number(await tokenContract.decimals()); } catch (_) {}

      const now = BigInt(Math.floor(Date.now() / 1000));
      let rwEnd = 0n;
      try { rwEnd = await readContract.rulingDeadline(id); } catch (_) {}

      let status, statusClass;
      if (conceded) { status = "Conceded"; statusClass = "status-conceded"; }
      else if (settled) { status = "Settled"; statusClass = "status-settled"; }
      else if (rwEnd > 0n && now > rwEnd) { status = "Timeout"; statusClass = "status-expired"; }
      else if (now > deadline) { status = "Ruling"; statusClass = "status-active"; }
      else { status = "Active"; statusClass = "status-active"; }

      const ua = userAddr.toLowerCase();
      const isPoster = ua === poster.toLowerCase();
      const isJudge = ua === judge.toLowerCase();
      const challengeCount = Number(await readContract.getChallengeCount(id));
      let isChallenger = false;
      for (let i = 0; i < challengeCount; i++) {
        const [cAddr] = await readContract.getChallenge(id, i);
        if (cAddr.toLowerCase() === ua) { isChallenger = true; break; }
      }

      let roles = [];
      if (isPoster) roles.push("Poster");
      if (isJudge) roles.push("Judge");
      if (isChallenger) roles.push("Challenger");
      const role = roles.join(" & ");

      const desc = metadata || "No description";
      let dispAmt = bondAmount;
      if (myBondsSdaiRate && token.toLowerCase() === SDAI_ADDRESS.toLowerCase()) {
        dispAmt = bondAmount * myBondsSdaiRate / ethers.parseUnits('1', 18);
      }
      const amtStr = parseFloat(ethers.formatUnits(dispAmt, decimals)).toLocaleString(undefined, { maximumFractionDigits: 2 });
      const displayName = friendlyTokenName(token, symbol);

      const item = document.createElement("div");
      item.className = "bond-item";
      item.onclick = () => viewBondById(id);
      item.innerHTML = `
        <div class="bi-left">
          <div class="bi-id">Bond #${id} <span class="status-badge ${statusClass}" style="font-size:10px;vertical-align:middle;">${status}</span></div>
          <div class="bi-meta">${escapeHtml(desc)}</div>
        </div>
        <div class="bi-right">
          <div class="bi-amount">$${amtStr}</div>
          <div class="bi-role">${role}</div>
        </div>`;
      listEl.appendChild(item);
    }

    myBondsLoaded = true;
  } catch (err) {
    loadingEl.classList.add("hidden");
    listEl.innerHTML = `<div class="msg msg-error">Error loading bonds: ${err.message}</div>`;
  }
}

// ─── Judge Registry ───────────────────────────────────────────────────
let judgesLoaded = false;
let judgesList = []; // cached list of {address, tokenFees: Map<tokenAddr, bigint>, bondCount}

// Get the currently selected token address on the create bond form
function getSelectedTokenAddr() {
  const sel = document.getElementById("tokenSelect");
  return sel ? sel.value : chain().defaultToken.address;
}

// Format a judge's per-token fee for the currently selected token
function formatJudgeFeeForToken(j) {
  const tokenAddr = getSelectedTokenAddr().toLowerCase();
  const fee = j.tokenFees.get(tokenAddr);
  if (!fee || fee === 0n) return "free";
  const tok = getAllTokens().find(t => t.address.toLowerCase() === tokenAddr);
  const decimals = tok ? (tok.decimals || 18) : 18;
  return parseFloat(ethers.formatUnits(fee, decimals)).toLocaleString(undefined, { maximumFractionDigits: 6 });
}

async function loadJudges() {
  const listEl = document.getElementById("judgesList");
  const loadingEl = document.getElementById("judgesLoading");
  const emptyEl = document.getElementById("judgesEmpty");

  // Show/hide register form based on connection
  if (userAddr) {
    document.getElementById("judgeRegisterPrompt").classList.add("hidden");
    // Check if current user is registered
    try {
      const readProvider = new ethers.JsonRpcProvider(chain().rpc);
      const readContract = new ethers.Contract(chain().contract, BOND_ABI, readProvider);
      const registered = await readContract.judges(userAddr);
      if (registered) {
        document.getElementById("judgeRegisterForm").classList.add("hidden");
        const ownStatus = document.getElementById("judgeOwnStatus");
        ownStatus.classList.remove("hidden");
        // Build token select for setting fees
        const tokenSel = document.getElementById("judgeTokenSelect");
        tokenSel.innerHTML = "";
        for (const t of getAllTokens()) {
          const opt = document.createElement("option");
          opt.value = t.address;
          opt.textContent = t.symbol || short(t.address);
          tokenSel.appendChild(opt);
        }
        // Show current per-token fees
        await refreshOwnJudgeFees(readContract);
      } else {
        document.getElementById("judgeRegisterForm").classList.remove("hidden");
        document.getElementById("judgeOwnStatus").classList.add("hidden");
      }
    } catch (_) {
      document.getElementById("judgeRegisterForm").classList.remove("hidden");
    }
  } else {
    document.getElementById("judgeRegisterPrompt").classList.remove("hidden");
    document.getElementById("judgeRegisterForm").classList.add("hidden");
    document.getElementById("judgeOwnStatus").classList.add("hidden");
  }

  if (judgesLoaded) return;

  loadingEl.classList.remove("hidden");
  listEl.innerHTML = "";
  emptyEl.classList.add("hidden");

  try {
    const readProvider = new ethers.JsonRpcProvider(chain().rpc);
    const readContract = new ethers.Contract(chain().contract, BOND_ABI, readProvider);

    // Scan JudgeRegistered events to find all judge addresses
    const regFilter = readContract.filters.JudgeRegistered();
    const regEvents = await readContract.queryFilter(regFilter, chain().deployBlock).catch(() => []);

    const judgeAddrs = new Set();
    for (const ev of regEvents) {
      judgeAddrs.add(ev.args.judge.toLowerCase());
    }

    // Scan JudgeFeeUpdated events to get per-token fees
    const feeFilter = readContract.filters.JudgeFeeUpdated();
    const feeEvents = await readContract.queryFilter(feeFilter, chain().deployBlock).catch(() => []);

    // Build fee map: judge -> token -> fee (latest event wins)
    const feeMap = new Map(); // judgeAddr -> Map<tokenAddr, bigint>
    for (const ev of feeEvents) {
      const judgeKey = ev.args.judge.toLowerCase();
      const tokenKey = ev.args.token.toLowerCase();
      if (!feeMap.has(judgeKey)) feeMap.set(judgeKey, new Map());
      feeMap.get(judgeKey).set(tokenKey, ev.args.newMinFee);
    }

    // Filter to currently registered by checking contract state
    judgesList = [];
    for (const addr of judgeAddrs) {
      try {
        // Use checksummed address from events
        const checksumAddr = regEvents.find(e => e.args.judge.toLowerCase() === addr)?.args.judge;
        if (!checksumAddr) continue;
        const registered = await readContract.judges(checksumAddr);
        if (registered) {
          const bondFilter = readContract.filters.BondCreated(null, null, checksumAddr);
          const bondEvents = await readContract.queryFilter(bondFilter, chain().deployBlock).catch(() => []);
          judgesList.push({
            address: checksumAddr,
            tokenFees: feeMap.get(addr) || new Map(),
            bondCount: bondEvents.length,
          });
        }
      } catch (_) {}
    }

    loadingEl.classList.add("hidden");

    if (judgesList.length === 0) {
      emptyEl.classList.remove("hidden");
      judgesLoaded = true;
      return;
    }

    // Sort by bond count descending
    judgesList.sort((a, b) => b.bondCount - a.bondCount);

    const currentToken = getSelectedTokenAddr().toLowerCase();
    for (const j of judgesList) {
      const feeStr = formatJudgeFeeForToken(j);
      const tok = getAllTokens().find(t => t.address.toLowerCase() === currentToken);
      const symbol = tok ? tok.symbol : "token";
      const isMe = userAddr && j.address.toLowerCase() === userAddr.toLowerCase();
      const item = document.createElement("div");
      item.className = "judge-item";
      const feesHtml = j.tokenFees.size > 0
        ? [...j.tokenFees.entries()].map(([tAddr, fee]) => {
            const t = getAllTokens().find(t => t.address.toLowerCase() === tAddr);
            const sym = t ? t.symbol : short(tAddr);
            const dec = t ? (t.decimals || 18) : 18;
            const fStr = fee === 0n ? "free" : parseFloat(ethers.formatUnits(fee, dec)).toLocaleString(undefined, { maximumFractionDigits: 6 });
            return `${sym}: ${fStr}`;
          }).join(", ")
        : "no fees set (free for all tokens)";
      item.innerHTML = `
        <div>
          <div class="ji-addr">${short(j.address)}${isMe ? ' <span style="color:var(--accent);">(you)</span>' : ''}</div>
          <div class="ji-fee">Min fees: ${feesHtml}</div>
          <div class="ji-bonds">${j.bondCount} bond${j.bondCount !== 1 ? 's' : ''} judged</div>
        </div>`;
      resolveEns(j.address).then(name => {
        if (name) {
          item.querySelector('.ji-addr').innerHTML = `${name} (${short(j.address)})${isMe ? ' <span style="color:var(--accent);">(you)</span>' : ''}`;
        }
      });
      listEl.appendChild(item);
    }

    judgesLoaded = true;
    buildJudgeSelect();
  } catch (err) {
    loadingEl.classList.add("hidden");
    listEl.innerHTML = `<div class="msg msg-error">Error loading judges: ${err.message}</div>`;
  }
}

async function refreshOwnJudgeFees(readContract) {
  const feesEl = document.getElementById("judgeOwnFees");
  const tokens = getAllTokens();
  const lines = [];
  for (const t of tokens) {
    try {
      const fee = await readContract.getJudgeMinFee(userAddr, t.address);
      const fStr = fee === 0n ? "free" : parseFloat(ethers.formatUnits(fee, t.decimals || 18)).toLocaleString(undefined, { maximumFractionDigits: 6 });
      lines.push(`${t.symbol}: ${fStr}`);
    } catch (_) {
      lines.push(`${t.symbol}: free`);
    }
  }
  feesEl.innerHTML = "Per-token min fees: " + (lines.length > 0 ? lines.join(" · ") : "none set");
}

function buildJudgeSelect() {
  const sel = document.getElementById("judgeSelect");
  const prev = sel.value;
  sel.innerHTML = '<option value="">Select a registered judge...</option>';
  const currentToken = getSelectedTokenAddr().toLowerCase();
  for (const j of judgesList) {
    const opt = document.createElement("option");
    opt.value = j.address;
    const feeStr = formatJudgeFeeForToken(j);
    const tok = getAllTokens().find(t => t.address.toLowerCase() === currentToken);
    const symbol = tok ? tok.symbol : "token";
    opt.textContent = `${short(j.address)} — ${symbol} fee: ${feeStr}`;
    resolveEns(j.address).then(name => {
      if (name) opt.textContent = `${name} — ${symbol} fee: ${feeStr}`;
    });
    sel.appendChild(opt);
  }
  const customOpt = document.createElement("option");
  customOpt.value = "__custom__";
  customOpt.textContent = "Custom address...";
  sel.appendChild(customOpt);

  if (prev && [...sel.options].some(o => o.value === prev)) sel.value = prev;
}

async function loadJudgeSelectOnCreate() {
  if (judgesList.length === 0) {
    try {
      const readProvider = new ethers.JsonRpcProvider(chain().rpc);
      const readContract = new ethers.Contract(chain().contract, BOND_ABI, readProvider);

      const regFilter = readContract.filters.JudgeRegistered();
      const regEvents = await readContract.queryFilter(regFilter, chain().deployBlock).catch(() => []);
      const feeFilter = readContract.filters.JudgeFeeUpdated();
      const feeEvents = await readContract.queryFilter(feeFilter, chain().deployBlock).catch(() => []);

      const judgeAddrs = new Map(); // addr -> checksumAddr
      for (const ev of regEvents) {
        judgeAddrs.set(ev.args.judge.toLowerCase(), ev.args.judge);
      }

      const feeMap = new Map();
      for (const ev of feeEvents) {
        const judgeKey = ev.args.judge.toLowerCase();
        const tokenKey = ev.args.token.toLowerCase();
        if (!feeMap.has(judgeKey)) feeMap.set(judgeKey, new Map());
        feeMap.get(judgeKey).set(tokenKey, ev.args.newMinFee);
      }

      judgesList = [];
      for (const [addr, checksumAddr] of judgeAddrs) {
        try {
          const registered = await readContract.judges(checksumAddr);
          if (registered) {
            judgesList.push({ address: checksumAddr, tokenFees: feeMap.get(addr) || new Map(), bondCount: 0 });
          }
        } catch (_) {}
      }
    } catch (_) {}
  }
  buildJudgeSelect();
}

function onJudgeSelectChange() {
  const val = document.getElementById("judgeSelect").value;
  const customField = document.getElementById("judgeCustomField");
  const hintEl = document.getElementById("judgeMinFeeHint");

  if (val === "__custom__") {
    customField.classList.remove("hidden");
    hintEl.textContent = "Enter a registered judge address. The judge must be registered on-chain.";
  } else if (val) {
    customField.classList.add("hidden");
    const j = judgesList.find(j => j.address.toLowerCase() === val.toLowerCase());
    if (j) {
      const feeStr = formatJudgeFeeForToken(j);
      const currentToken = getSelectedTokenAddr().toLowerCase();
      const tok = getAllTokens().find(t => t.address.toLowerCase() === currentToken);
      const symbol = tok ? tok.symbol : "token";
      hintEl.textContent = `Minimum ${symbol} fee: ${feeStr} per ruling.`;
      // Auto-set judge fee if user hasn't edited
      const feeEl = document.getElementById("judgeFee");
      if (!feeEl.dataset.userEdited) {
        const fee = j.tokenFees.get(currentToken);
        if (fee && fee > 0n) {
          const dec = tok ? (tok.decimals || 18) : 18;
          feeEl.value = parseFloat(ethers.formatUnits(fee, dec)).toFixed(2);
        } else {
          // No fee set for this token — use default 5% of bond
        }
      }
    }
  } else {
    customField.classList.add("hidden");
    hintEl.textContent = "The judge rules on challenges. Pick someone both parties trust.";
  }
}

async function doRegisterJudge() {
  if (!signer) return;
  const msg = document.getElementById("judgesMsg");
  try {
    showMsg(msg, "Registering...", "info");
    const tx = await bondContract.registerAsJudge();
    await waitForTx(tx);
    showMsg(msg, "Registered as judge! Now set per-token minimum fees.", "success");
    judgesLoaded = false;
    loadJudges();
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  }
}

async function doSetJudgeFee() {
  if (!signer) return;
  const msg = document.getElementById("judgesMsg");
  const tokenAddr = document.getElementById("judgeTokenSelect").value;
  const feeStr = document.getElementById("judgeNewFee").value.trim() || "0";
  if (!tokenAddr) { showMsg(msg, "Select a token", "error"); return; }
  try {
    const tok = getAllTokens().find(t => t.address.toLowerCase() === tokenAddr.toLowerCase());
    const decimals = tok ? (tok.decimals || 18) : 18;
    const fee = ethers.parseUnits(feeStr, decimals);
    const symbol = tok ? tok.symbol : short(tokenAddr);
    showMsg(msg, `Setting ${symbol} fee...`, "info");
    const tx = await bondContract.setJudgeFee(tokenAddr, fee);
    await waitForTx(tx);
    showMsg(msg, `${symbol} fee updated!`, "success");
    judgesLoaded = false;
    loadJudges();
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  }
}

async function doDeregisterJudge() {
  if (!signer) return;
  const msg = document.getElementById("judgesMsg");
  if (!confirm("Deregister as judge? You must still rule on existing bonds.")) return;
  try {
    showMsg(msg, "Deregistering...", "info");
    const tx = await bondContract.deregisterAsJudge();
    await waitForTx(tx);
    showMsg(msg, "Deregistered. Existing bonds are unaffected.", "success");
    judgesLoaded = false;
    loadJudges();
  } catch (err) {
    showMsg(msg, err.reason || err.message, "error");
  }
}

async function doRejectBond(bondId) {
  const msg = document.getElementById("viewMsg");
  if (!confirm("Reject this bond? All parties will be refunded. You will not receive any fee.")) return;
  try {
    showMsg(msg, "Processing rejection...", "info");
    const tx = await bondContract.rejectBond(bondId);
    await waitForTx(tx);
    showMsg(msg, "Bond rejected. All parties refunded.", "success");
    loadBond();
  } catch (err) { showMsg(msg, err.reason || err.message, "error"); }
}

// ─── Form persistence ─────────────────────────────────────────────────
const FORM_FIELDS = ["tokenSelect", "bondAmount", "challengeAmount", "judgeFee", "judgeSelect", "judgeAddr", "bondMetadata", "deadline", "bondIdInput"];

function saveForm() {
  const data = {};
  for (const id of FORM_FIELDS) {
    const el = document.getElementById(id);
    if (el) data[id] = el.value;
  }
  data._rulingBuffer = rulingBufferDays;
  data._acceptanceDelay = acceptanceDelayDays;
  const activeTab = document.querySelector(".tab.active");
  if (activeTab) data._tab = activeTab.dataset.tab;
  sessionStorage.setItem("bondForm", JSON.stringify(data));
}

function restoreForm() {
  try {
    const raw = sessionStorage.getItem("bondForm");
    if (!raw) return;
    const data = JSON.parse(raw);
    for (const id of FORM_FIELDS) {
      const el = document.getElementById(id);
      if (el && data[id]) el.value = data[id];
    }
    if (data._rulingBuffer) setRulingBuffer(data._rulingBuffer);
    if (data._acceptanceDelay) setAcceptanceDelay(data._acceptanceDelay);
    if (data._tab) switchTab(data._tab);
  } catch (_) {}
}

// ─── Init ─────────────────────────────────────────────────────────────
function getChainIdFromParam(param) {
  const map = { gnosis: 100, polygon: 137, ethereum: 1 };
  return map[param.toLowerCase()] || 100;
}

window.addEventListener("DOMContentLoaded", async () => {
  // Parse chain from URL
  const params = new URLSearchParams(window.location.search);
  const chainParam = params.get("chain");
  if (chainParam) {
    activeChainId = getChainIdFromParam(chainParam);
    document.getElementById("chainSelect").value = String(activeChainId);
  }
  document.getElementById("footerChain").textContent = chain().name;

  buildTokenSelect();
  document.getElementById("tokenSelect").value = chain().defaultToken.address;
  setMode('simple');
  loadJudgeSelectOnCreate();
  restoreForm();

  const bondParam = params.get("bond");
  if (bondParam !== null) {
    // Deep link: show main app and go to view tab
    document.getElementById("connectScreen").classList.add("hidden");
    document.getElementById("mainApp").classList.remove("hidden");
    document.getElementById("connectBtn").classList.remove("hidden");
    switchTab("view");
    document.getElementById("bondIdInput").value = bondParam;
    setTimeout(() => loadBond(), 500);
  }

  // Try auto-reconnect
  let autoConnected = false;

  // Check Web3Auth reconnection
  if (WEB3AUTH_CLIENT_ID !== "YOUR_WEB3AUTH_CLIENT_ID") {
    try {
      const w3a = await initWeb3Auth();
      if (w3a && w3a.connected) {
        web3authProvider = w3a.provider;
        connectionType = 'web3auth';
        provider = new ethers.BrowserProvider(w3a.provider);
        signer = await provider.getSigner();
        userAddr = await signer.getAddress();
        bondContract = new ethers.Contract(chain().contract, BOND_ABI, signer);
        onWalletConnected();
        autoConnected = true;
      }
    } catch (_) {}
  }

  // Check injected wallet reconnection
  if (!autoConnected && window.ethereum) {
    try {
      const accounts = await window.ethereum.request({ method: "eth_accounts" });
      if (accounts && accounts.length > 0) {
        await connectInjectedWallet();
        autoConnected = true;
      }
    } catch (_) {}
  }

  // If no auto-connect and no deep link, show connect screen
  if (!autoConnected && bondParam === null) {
    showConnectScreen();
  }

  // Save form on unload
  window.addEventListener("beforeunload", saveForm);
});
</script>
</body>
</html>
